[{"content":"正则表达式 必备常识\n   正则表达式 描述 示例     ^ 以某内容开头 ^hel匹配hello   $ 以某内容结尾 llo$匹配hello   . 匹配任意一个字符 Hack.匹配Hacki   [ ] 匹配括号内中的任意一个字符 [0-9]匹配任意一个数字   [^] 匹配不属于括号内中的任意一个字符 [^.]匹配除.以外的任意字符   [[:xxx:]] xxx表示一些命名字符类 [[:alpha:]]匹配字符[[:digit:]]匹配数字   \\b 匹配单词开头或结尾的项 \\bth\\b只匹配th   \\B 匹配非单词开头或结尾的项 \\Bth\\B匹配other但不匹配this或oith   ？ 匹配之前的项0次或1次 colou?r匹配color或colour   + 匹配之前的项1次或多次 [0-9]+匹配9或99或999   * 匹配之前的项0次或多次 co*l匹配cl或col或cool   {n} 匹配之前的项n次 [a-z]{3}匹配任意3个字符   {n, } 匹配之前的项至少n次 [a-z]{3, }匹配abc或abcd   { ,m} 匹配之前的项最多m次 [a-z]{ ,2}匹配a或ab   {n, m} n \u0026lt;= 匹配之前的项次数 \u0026lt;= m [a-z]{1, 2}匹配a或ab   | 匹配|两边的任意一项 th(is|at)匹配this或that   ( ) ( )作为一个单元,可以对其使用数量限定符 b(a[0-9])?匹配b或ba1   \\ 转义前面的特殊符号,表达正常字符 [a-b]\\.txt匹配a.txt或b.txt    注意事项：\n正则表达式在实现内容查找时，会选择最长的匹配。\n如：字符串this is a test 和正则表达式 s.*s\n匹配的内容则是s is a tes, 而非 s is\n再举一例（结合sed）：\n在一个html页面中，如果想去掉其标签而留下里面的内容：\n1 2 3 4 5 6 7 8 9 10 11 12  cat index.html \u0026lt;html\u0026gt;\u0026lt;span\u0026gt;I am a \u0026lt;strong\u0026gt;c++\u0026lt;/strong\u0026gt; programmer!\u0026lt;/span\u0026gt;\u0026lt;/html\u0026gt; # 使用以下正则表达式,是无法正确显示的 # 由于正则表达式会选择最长匹配的特性，这样做直接会将整行文本替换为空格 sed \u0026#39;s/\u0026lt;.*\u0026gt;//g\u0026#39; index.html # 正确的做法 sed \u0026#39;s/\u0026lt;[^\u0026gt;]*\u0026gt;//g\u0026#39; index.html # 输出 I am a c++ programmer!   find   选项-name\n指定文件名进行模糊查找\n例如：\n统计一下当前整个目录下的c文件的数量\n  1  find . -name *.c | wc -l   忽略大小写 可以用-iname 选项\n还可以用!来表示相反操作\n如：查找当前整个目录下不是c文件的文件\n1  find . ! -name *.c     选项-a/-and/-o/-or\n支持逻辑操作符：逻辑与（-a/-and）、逻辑或（-o/-or）\n例如查找c文件和头文件（需要用括号将查找条件括起来，当做一个整体）\n  1  find . \\( -name \u0026#39;*.c\u0026#39; -o -name \u0026#39;*.h\u0026#39; \\)     选项-type\n指定文件类型进行查找\n例如：\n在当前目录下遍历整个目录查找符号文件\n  1  find . -type l   type 可以取值d/p/s/c/l/f/b对应目录/fifo/套接字/字符设备/符号链接/普通文件/块设备\n  选项-size\n指定文件大小进行查找\n文件大小单位：b/c/w/k/M/G 对应 521字节/1字节/2字节/1024字节/1024k/1024M\n默认单位：b\n例如：\n  1 2 3  $ find . -type f -size +2k # 大于2k的文件 $ find . -type f -size -2k # 小于2k的文件 $ find . -type f -size 2k # 等于2k的文件     选项-maxdepth\n默认不加-maxdepth选项会递归查找到最后一级目录\n-maxdepth 指定查找深度\n例如：\n查找当前目录下的mp3文件\n  1  find . -maxdepth 1 -name *.mp3     选项-atime/mtime/ctime\n可以根据文件的日期时间来进行查找\natime: 用户最后一次访问文件的时间。\nmtime: 文件内容最后一次被修改的时间\nctime: 文件元数据（权限或所有权）最后一次被改变的时间\n默认以天作为单位\n例如：\n  1 2 3 4 5 6 7 8  # 打印出最近7天内被访问过的所有文件 $ find . -type f atime -7 -print # 打印出恰好在7天前被访问过的所有文件 $ find . -type f atime 7 -print # 打印出访问时间超过7天的所有文件 $ find . -type f atime +7 -print     选项-amin/mmin/cmin\n默认以分钟作为单位\namin/mmin/cmin 对应atime/mtime/ctime\n  选项-perm\n指定文件权限来查找\n例如：\n  1  find . -type f -perm 664 -print     选项-exec\n通过选项-exec，find可以结合其他命令使用\n例如：\n把所有者为root的文件修改文件所有者为slynux\n  1  find . -type f -user root -exec chown slynux {} \\;   { }表示前面找到的文件\n\\; 以分号作为结束标记，需要转义\n  选项-regex\n通过该选项可以使用正则表达式匹配\n例如：\n找当前目录下的python文件和shell文件，括号和|都要转义\n  1  find . -maxdepth 1 -regex \u0026#39;.*\\.\\(py\\|sh\\)$\u0026#39;    结合xargs使用\n查找文件并显示详细信息  1  find . -type f -print0 | xargs -0 ls -l   print选项使用\\n(换行符)分隔输出的每个文件或目录名。而-print0选项则使用空字符 \u0026lsquo;\\0\u0026rsquo;来分隔。\n-print0的主要用法是将包含换行符或空白字符的文件名传给xargs命令\n扩展 xargs xargs 命令应该紧跟在管道操作符之后，xargs会从stdin读出并作为参数\n 选项-n指定每次传入的参数个数  1 2 3 4  echo -e \u0026#34;1\\n2\\n3\\n4\\n5\u0026#34; | xargs -n 2 # 输出 1 2 3 4    选项-d指定分割符，xargs默认分割符为换行或者空格或者制表符  1 2 3 4  echo -e \u0026#34;123a456a789\u0026#34; | xargs -d a # 输出 123 456 789    选项-I  1 2 3 4 5 6 7 8 9 10 11 12 13  cat args.txt # 输出 arg1 arg2 arg3 # -I {} 是指定要替换的字符串(每一个参数), # 后面的{} 指的就是当前参数, 这会循环地读取每一个参数 cat args.txt | xargs -I {} echo argA {} argB # 输出 argA arg1 argB argA arg2 argB argA arg3 argB   tr  选项-d\n指定删除字符集合  1 2 3  echo abcd1234efg | tr -d \u0026#39;0-9\u0026#39; # 输出 abcdefg    选项-c\n指定字符集合的补集\n格式：tr -d -c [set] 指定删除不在set集合中的字符\n格式: tr -c [set1] [set2] 指定不在set1集合中的字符用set2集合的字符代替  1 2 3 4 5 6  echo labc2bcde3a | tr -d -c \u0026#39;0-9\u0026#39; # 输出 123 echo 1abc2bcde3a | tr -c \u0026#39;0-9\u0026#39; \u0026#39; \u0026#39; 1 2 3    将数字列表进行加法运算  1  echo -e \u0026#34;1\\n2\\n3\\n4\u0026#34; | echo $[ $(tr \u0026#39;\\n\u0026#39; \u0026#39;+\u0026#39; ) 0 ]    tr可以将不同的字符类作为集合使用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 小写转大写 echo abcdefg | tr \u0026#39;[:lower:]\u0026#39; \u0026#39;[:upper:]\u0026#39; # 输出 ABCDEFG # 字符集类总览 # alnum 字母和数字 # alpha 字母 # cntrl 控制（非打印）字符 # digit 数字 # graph 图形字符 # lower 小写字符 # upper 大写字符 # print 可打印字符 # punct 标点字符 # space 空白字符 # xdigit 十六进制字符   sort 对文件内容进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # 将文件file1和file2的内容排序输出到文件sorted.txt sort file1.txt file2.txt \u0026gt; sorted.txt # 按照数字进行排序 sort -n file.txt # 按照逆序进行排序 sort -r file.txt # 按照月份排序 sort -M months.txt # 检测文件是否已排序过, 返回值为0表示排序过 sort -c file.txt # 指定列进行排序(此例指定第二列) sort -k 2 file.txt # 与xargs结合，其每个参数的终止符必须保持一致 sort -z data.txt | xargs -0   uniq 查重去重, 使用的前提条件必须是已排过序的文本,\n基本上是与sort组合使用的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  cat unsorted.txt # 输出 foss bash hack hack # 去除重复的 sort unsorted.txt | uniq # 输出 bash foss hack # 只显示唯一、不重复的内容，也就是说重复的内容一条都不显示 sort unsorted.txt | uniq -u # 输出  bash foss # 统计每条记录出现的数量 sort unsorted.txt | uniq -c # 输出 1 bash 1 foss 2 hack # 显示重复的记录 sort unsorted.txt | uniq -d # 输出 hack # uniq还可以指定从那开始比较,重复的直接删除 # 用-s指定跳过N个字符，用-w指定用于比较的最大字符数 cat data.txt # 输出 u:01:gnu d:04:linux u:01:hack u:01:bash sort data.txt | uniq -s 2 -w 2 d:04:linux u:01:bash # 与xargs结合s使用 uniq -z file.txt | xargs -0 rm   ","description":"find常用场景","id":2,"section":"posts","tags":["linux命令"],"title":"linux command -- find","uri":"http://blog.nstop.cn/posts/linux/find/"},{"content":"c++设计模式 前言： 我们往往在学习设计模式的时候，总很机械地去想着生搬硬套在某个项目模块中，但这种做法其实违背了设计模式的初衷，设计模式是为了更好地去适应将来的变化，其核心在于隔离稳定和变化的部分，使二者之间的联系不再那么紧密，从而达到我们平常所说的松耦合。而如何能够更好的运用设计模式，并不是你把23种设计模式都记在脑子里，而是在面向对象设计原则的基础上来设计。设计模式的本质是离不开面向对象设计原则的。\n面向对象设计原则  依赖倒置原则（DIP）\n高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）\n抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定） 开放封闭原则（OCP）\n对扩展开放，对更改封闭\n类模块应该是可扩展的，但是不可修改。 单一职责原则（SRP）\n一个类应该仅有一个引起它变化的原因\n变化的方向隐含着类的责任 Liskov替换原则（LSP）\n子类必须能够替换它们的基类（IS-A）\n继承表达类型抽象 接口隔离原则（ISP）\n不应该强迫客户程序依赖它们不用的方法\n接口应该小而完备 优先使用对象组合，而不是类继承\n类继承通常为\u0026quot;白箱复用\u0026quot;，对象组合通常为“黑箱复用”\n继承在某种程度上破坏了封装性，子类父类耦合度高\n而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。 封装变化点\n使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。 针对接口编程，而不是针对实现编程\n不将变量类型声明为某个特定的具体类，而是声明为某接口\n客户程序无需获知对象的具体类型，只需要知道对象所具有的接口\n减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”的类型设计方案。  重构的关键技法   静态 ===\u0026gt; 动态\n  早绑定 ===\u0026gt; 晚绑定\n  继承 ===\u0026gt; 组合\n  编译时依赖 ===\u0026gt; 运行时依赖\n  紧耦合 ===\u0026gt; 松耦合\n  23种设计模式 Template Method（模板方法） 定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中。Template Method使得子类可以不改变（复用）一个算法的结果即可重定义（override 重写）该算法的某些特定步骤。\nTemplate Method模式是一种非常基础性的设计模式，其根本的机制就是借用虚函数来实现晚绑定，从而为很多应用程序框架提供了灵活多变的扩展点，具有代码复用方面的基本实现结构。\n应用场景：\n一个功能模块实现的流程已经确定，但其中某些方法现在不能确定其具体实现，因为随着将来的需求会发生各种各样的变化，所以这时候可以考虑设计模式的应用，想想这里的变化部分和稳定部分，稳定部分是一个应用框架流程以及流程中某些确定下来的方法，而变化的部分就是其可扩展的方法实现变化。\nc++ example：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  class Library{ public: //Template Method 模板方法设计模式  void run(){ step1(); if (step2() //可变化，子类重写，利用虚函数机制调用到子类的方法){  step3(); } for (int i = 0; i \u0026lt; 4; i++) { step4();//可变化，子类重写，利用虚函数机制调用到子类的方法  } step5(); } //需要虚析构函数，防止子类调用不到自己的析构函数  vitraul ~Library() {} protected: void step1(){ //...稳定  } void step3(){ //...稳定  } void step5(){ //...稳定  } //变化，可扩展,把它们设为protected的而不是public，是因为这些方法对外开放没有什么实际意义，只是为了让子类来重写调用  virtual bool step2() = 0; virtual void step4() = 0; } class Application ：public Library{ public: virtual bool step2(){ //...重写（根据自己的实际需求进行代码设计）  } virtual void step4(){ //...重写（根据自己的实际需求进行代码设计）  } } //主函数 int main(void) { Library *application = new Application(); application-\u0026gt;run(); //执行稳定流程方法，晚绑定  delete application; return 0; }   Strategy（策略模式） 定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。\nStrategy及其子类为组建提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。\nStrategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。\n如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。//单例模式\n策略模式是开放封闭原则的典型运用\n应用场景：\nexample c++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  //税率策略类 class TaxStrategy{ public: virtual double Calculate(const Context\u0026amp; context) = 0; virtual ~TaxStrategy(){} //只要是基类就要写虚析构函数，除非此类永远不能被继承 } //每一种税率继承其策略类，根据实际业务重写其Calculate方法 class CNTax : public TaxStrategy{ public: virtual double Calculate(const Context\u0026amp; context){ //...中国税率计算  } } class USTax : public TaxStrategy{ public: virtual double Calculate(const Context\u0026amp; context){ //...美国税率计算  } } class DETax : public TaxStrategy{ public: virtual double Calculate(const Context\u0026amp; context){ //...德国税率计算  } } //还可根据后来变化扩展更多的税率计算 //....  //订单类需要用到税率 class SalesOrder{ private: TaxStrategy* taxStrategy; public: //涉及到工厂模式  SalesOrder(StrategyFactory* strategyFactory){ this-\u0026gt;taxStrategy = strategyFactory-\u0026gt;NewStrategy(); } ~SalesOrder(){ delete this-\u0026gt;taxStrategy; } public double CalculateTax(){ //...此处省略一些代码逻辑  Context context();//获得上下文  //利用多态机制调用实际需要的TaxStrategy子类方法  double val = strategy-\u0026gt;Calculate(context); //...此处省略一些代码逻辑  } }   Observer（观察者模式） 定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。\n 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达到松耦合。 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。 观察者自己决定是否需要订阅通知，目标对象对此一无所知。 Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。  example C++（文件分割器）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  public MainForm : public Form, public IProgress{ private: TextBox* txtFilePath; TextBox* txtFileNumber; public: void Button1_click(){ string filePath = txtFilePath-\u0026gt;getText(); int fileNum = atoi(txtFileNumber-\u0026gt;getText().c_str()); FileSplitter splitter(filePath, fileNum); //添加通知成员MainForm类对象  splitter.addProgress(this); ConsoleNotifier cn; //添加通知成员ConsoleNotifier类对象  splitter.addProgress(\u0026amp;cn); splitter.addProgress(this); splitter.split(); } //重写进度条逻辑  virtual void DoProgress(float value){ //...  } } class ConsoleNotifier : public IProgress{ //通知逻辑  virtual void DoProgress(float value){ cout \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; } } class FileSplitter{ private: string m_filePath; int m_fileNum; vector\u0026lt;IProgress*\u0026gt; m_iprogress; //抽象通知机制（多个通知） public: FileSplitter(const string\u0026amp; filePath, int fileNum) : m_filePath(filePath), m_fileNum(fileNum){ } void addProgress(IProgress* progress){ m_iprogress.push_back(progress); } void removeProgress(IProgress* progress){ m_iprogress.remove(progress); } void split(){ for(int i = 0; i \u0026lt; fileNum; i++){ //文件分割业务逻辑  //...  //进度条逻辑  float progressValue = fileNum; progressValue = i / progressValue; OnProgress(progressValue); } } protected: //这里有需求的时候可以写成虚函数，可供后者继承重写逻辑  void OnProgress(float value){ //通知所有成员  for(auto progress : m_iprogress){ progress-\u0026gt;DoProgress(value); } } } //接口 class IProgress{ public: virtual void DoProgress(float value)=0; virtual ~IProgress(){} }   Decorator（装饰者模式） 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码\u0026amp;减少子类个数）。\n 通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能，避免了使用继承带来的“灵活性差”和“多子类衍生问题”。 Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。 Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。  Bridge（桥模式） Factory Method（工厂方法） Abstract Factory（抽象工厂） Prototype（原型模式） Builder（构建者模式） Singleton（单件模式） Flyweight（享元模式） Facade（门面模式） Proxy（代理模式） Adapter（适配器模式） Mediator（中介者模式） State（状态模式） Memento（备忘录模式） Composite（组合模式） Iterator（迭代器模式） Chain of Responsibility（职责链模式） Command（命令模式） Visitor（访问器模式） Interpreter（解析器模式） 23种设计模式根据面向对象设计原则进行分类 单一职责：装饰模式(Decorator)、桥模式(Bridge)\n","description":"没有人能教你如何设计一个好的class，但确有一些前人留下的好的设计思想","id":3,"section":"posts","tags":["设计模式"],"title":"浅谈设计模式","uri":"http://blog.nstop.cn/posts/cpp/design-pattern/"},{"content":"shell基础   echo 与 printf的区别：echo 自带换行，printf需要加回车转义符\\n\n  巧用小括号()：比如命令cd ..;ls -l 与 (cd ..;ls -l) 的区别在不加小括号的会改变到上一级的工作目录\n  变量：\n  变量类型：变量只有一种数据类型，都是字符串\n  变量生命周期分类：环境变量、本地变量\n  定义变量：变量名=值 ==\u0026gt; VAR=abc （变量名最好用大写）\n  取值：$VAR===\u0026gt; 打印VAR的值：echo $VAR\n  删除变量：unset 变量名 ===\u0026gt; unset VAR\n    alias用法：如用 ll 来代替 ls -l 功能，则用 alias ll='ls -l'\n  数字的四则运算：\n1 2 3 4 5 6  VAR=8 echo $(($VAR + 11)) 或者 echo $((VAR + 11)) 或者 echo $[VAR + 11]或者echo $[$VAR + 11] # 指定二进制或者八进制或者十六进制数 echo $[2#10 + 11] # 二进制 echo $[8#10 + 11] # 八进制 echo $[16#10 + 11] # 十六进制     通过打印变量来调用日期命令\n1 2  VAR=`date` echo $VAR   或者\necho $(date)\n  转义字符\\ 和--\n\u0026ndash;创建$$abc文件 ==========\u0026gt; touch \\$\\$abc\n\u0026ndash;创建---xyz文件==========\u0026gt; touch ./---xyz 或者 touch -- ---xyz\n  单引号'和双引号\u0026quot;\n双引号允许变量扩展\n测试：\nVAR=hello\necho '$VAR' =========\u0026gt; 显示结果为$VAR\necho \u0026quot;$VAR\u0026quot; =========\u0026gt; 显示结果为hello\n  条件测试 test 或者 []\necho $? =====\u0026gt; 输出上一次执行结果 0为真，1为假\n比较数字大小 ===== -gt -ge -eq -ne -lt -le\nexample: test $((1)) -eq $((2)) 或者[ $((1)) -eq $((2)) ]\n判断文件类型=====-d -f -p \nexample: test -d aa 或[ -d aa ]（假设在当前路径下存在aa目录）\n判断字符串长度是否为零 ==========\u0026gt;-n -z （-n不为零，-z为零）\n判断两个字符串是否相等 ==========\u0026gt;= !=\nexample:\nVAR=\ntest -n \u0026quot;$VAR\u0026quot; （这里需要打双引号，不然无法判断空串的长度，结果为假）\ntest -n $VAR （没加双引号的结果为真）\n[ \u0026quot;$VAR\u0026quot; != \u0026quot;$VAR\u0026quot; ]\n逻辑与、或、非 =============\u0026gt; -a -o !\n[ ! expr ]\n[ expr1 -a expr2 ]\n[ expr1 -o expr2 ]\n  接收键盘输入read\n   用法格式 read option 变量名 option:\n-p \u0026ldquo;提示信息\u0026rdquo;\n-t 秒数 等待用户输入的时间\n-n 字符数\n-s 隐藏输入的数据，使用于机密信息  if elif else fi  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #! /bash/bin  echo \u0026#34;please input number\u0026#34; read NUMBER # 相当于c语言的scanf if [ \u0026#34;$NUMBER\u0026#34; -eq 0 ]; then echo \u0026#34;你输入的是零\u0026#34; elif [ \u0026#34;$NUMBER\u0026#34; -gt 0 ]; then echo \u0026#34;你输入的是一个正数\u0026#34; else echo \u0026#34;你输入的是一个负数\u0026#34; fi if :; then echo \u0026#34;这个 ：表示永远为真\u0026#34; fi   case esac  1 2 3 4 5 6 7 8 9 10 11 12 13 14  #! /bash/bin  read -p \u0026#34;please input a word\u0026#34; WORD case \u0026#34;$WORD\u0026#34; in hello|Hello|HELLO) echo \u0026#34;你输入的是hello\u0026#34;;; world|World|WORLD) echo \u0026#34;你输入的是world\u0026#34;;; *) echo \u0026#34;你输入的是其他单词\u0026#34;;; esac return   foreach循环  逐行打印当前路径下的文件\n1 2 3 4 5  #!/bin/sh  for filename in $(ls); do echo $filename done   依次打印数字从1到100\n1 2 3 4 5  #!/bin/sh  for ((i=1;i\u0026lt;=100;i++)); do echo $i done   while循环  1 2 3 4 5 6  #!/bin/sh  read -p\u0026#34;please input your name: \u0026#34; NAME while [ \u0026#34;$NAME\u0026#34; != \u0026#34;wintersun\u0026#34; ]; do read -p\u0026#34;error, please try again: \u0026#34; NAME done   函数 正则表达式  ","description":"shell一些基础总结","id":4,"section":"posts","tags":["shell"],"title":"初识shell","uri":"http://blog.nstop.cn/posts/linux/shell/"},{"content":"centos7安装tesseract  直接安装tesseract  1  yum insatll tesseract   用pip源安装opencv-python 或者 pillow  1 2  pip3 install opencv-python pip3 install pillow   安装python所需要的pytesseract包  1  pip3 install pytesseract   安装字体  1 2 3 4  # 中文字体 yum install tesseract-langpack-chi-sim.noarch # 英文字体 yum install tesseract-langpack-eng.noarch   还想装更多的字体，请输入以下命令进行查找  1  yum search tesseract   pip源下载慢的话可以尝试以下两种解决办法   临时的  1  pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple package_name    永久的  1 2  pip3 install pip -U pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple   检验tesseract是否安装成功  1  tesseract --list-langs   命令行使用tesseract  1 2  # result是输出文本 [-l chi_sim]指定中文简体字体 tesseract verifycode.jpeg result -l chi_sim   python简单使用tesseract  1 2 3 4 5 6  from PIL import Image import pytesseract img = Image.open(\u0026#34;./verifycode.jpeg\u0026#34;) print(pytesseract.image_to_string(img))   ","description":"python图像识别工具安装","id":5,"section":"posts","tags":["python"],"title":"tesseract","uri":"http://blog.nstop.cn/posts/other/tesseract/"},{"content":"前言 sed 可以说是与 awk 是一对亲兄妹\nsed 主要是控制行的内容, 而 awk 则主要是控制列的内容, 二者相辅相成\nsed 与 vim 中有些用法雷同  简单尝试\nsed 's/pattern/replace_string/' file\npattern可以是任何正则表达式，replace_string代表要替换的字符串  1 2 3 4 5 6 7  cat file.txt 1 hello world hello world 2 hello world hello world sed \u0026#39;s/hello/HELLO/\u0026#39; file.txt 1 HELLO world hello world 2 HELLO world hello world   你会发现所有行中的第一个hello会被替换为HELLO\n扩展:\n 修改一行中所有的匹配项, 而不仅仅是第一个\nsed 's/pattern/replace_string/g' file 指定修改哪一行, 那么你可以这样\nsed '2s/pattern/replace_string/g' file 加个范围，比如你想只改第一行到第三行的内容\nsed '1,3s/pattern/replace_string/g' file 指定修改每行中的第几个匹配项\nsed '1,3s/pattern/replace_string/2g' file\n指的是修改一行中第二个匹配项 用模式到模式来表示范围\nsed '/pattern/,/pattern/ s/pattern/replace_string/g' file  1 2 3 4 5 6 7 8 9 10 11 12  cat file1.txt 1 this is a line. 2 there is a apple. 3 you are my friend. # 将存在单词line的那行到存在单词friend的那行替换其中的a为an sed \u0026#39;/line/,/friend/ s/a/an/\u0026#39; file1.txt # 输出 1 this is an line. 2 there is an apple. 3 you anre my friend.   已匹配字符串标记(\u0026amp;) \u0026amp; 可以替代前面匹配到的字符串\n1 2 3 4 5 6 7  # 将每个单词用[]括起来 echo this is a line | sed \u0026#39;s/\\w\\+/[\u0026amp;]/g\u0026#39; [this] [is] [a] [line] # 将每两个单词作为一组用[]括起来 echo this is a line | sed \u0026#39;s/\\w\\+ \\w\\+/[\u0026amp;]/g\u0026#39; [this is] [a line]   解释一下:\n\\w 表示任意一个字母, 后面加了个 +, 只不过用了转义 \\+\n\\w\\+ 就表示一个单词\n\u0026amp; 就替代了前面匹配到的单词本身\n字符串匹配标记(\\1) 在替换时，有些时候匹配模式的正则表达式会比较复杂，\n因此我们可以将前面匹配到的项拆分成几块来操作\n1 2 3  # 将seven 和 EIGHT的位置互换 echo seven EIGHT | sed \u0026#39;s/\\([a-z]\\+\\) \\([A-Z]\\+\\)/\\2 \\1/\u0026#39; EIGHT seven   s/\\([a-z]\\+\\) \\([A-Z]\\+\\)/\\2 \\1/ 初看起来比较复杂\n去掉转义符之后明了了许多: s/([a-z]+) ([A-Z]+)/\\2 \\1\n前面用圆括号()是把某个部分当做一个整体\n而 \\1 代表第一个整体, \\2 代表第二个整体\na、i、c、d、p  追加内容\n在第二行后另起一行加上this is a test\nsed '2a this is a test' file  1 2 3 4  echo -e \u0026#34;hello world!\\nyou are my friend\u0026#34; | sed \u0026#39;1a this is a test\u0026#39; hello world! this is a test you are my friend    插入内容\n在第一行到第三行前另起一行插入内容this is a test\nsed '1,3i this is a test' file 替换内容\n会先删除匹配所在行，再添加 this is a test 内容\nsed '/pattern/,/pattern/c this is a test' file 删除内容\n直接删除匹配所在行\n删除空行: sed '/^$/d' file 打印内容\n将匹配所在行打印  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  cat file.txt this is a dog. this is a cat. this is a fish. this is a women. sed \u0026#39;/cat/,/fish/p\u0026#39; file.txt # 你会发现第三行和第四行会被打印两次 this is a dog. this is a cat. this is a cat. this is a fish. this is a fish. this is a women. # 其实是因为无论匹配与否，内容都要打印一遍 # 因此你可以加上-n 不打印全部文本内容 sed \u0026#39;/cat/,/fish/p\u0026#39; file.txt this is a cat. this is a fish.   使用双引号 一般sed 后跟的都是单引号 ', 但有时侯也需要用到双引号 \u0026quot;\n 使用环境变量时  1 2 3 4 5  # 定义一个局部环境变量test test=hello # 由于双引号会扩展里面的内容 echo hello wolrd | sed \u0026#34;s/$test/HELLO/\u0026#34; HELLO world    匹配内容中有单引号时  1 2 3  # 如果外面还用单引号就会发生冲突 echo \u0026#34;you are he\u0026#39;s brother\u0026#34; | sed \u0026#34;s/\u0026#39;s/\u0026#39;S/\u0026#34; you are he\u0026#39;S brother   多个模式匹配  第一种\nsed -e 'expression' -e 'expression' file\n如：echo abc | sed -e 's/a/A/' -e 's/c/C/' 第二种\nsed 'expression;expression' file\n如：echo abc | sed 's/a/A/;s/c/C/'  取反! 除了匹配所在行外，其余行都执行操作\n1 2 3 4 5 6 7 8 9  cat file.txt 1 this is a dog. 2 this is a cat. 3 this is a fish. 4 this is a women. # 保留第二行，其他内容全部删除 sed \u0026#39;2!d\u0026#39; file.txt 2 this is a cat.   将修改后的内容反映到真实文件中去  第一种做法: 重定向\nsed 's/pattern/replace_string/' file.txt \u0026gt; file1.txt 第二种做法: 加参数-i\nsed 's/pattern/replace_string/' file.txt -i  总结 sed的用法大体形式是这样的: [address[,address]][!]{cmd}\n 大括号包含的是命令\n如: 对第3行到第6行，执行命令/this/d,\n也就是在第3行到第6行中查找匹配this那行并删除\nsed '3,6 {/this/d}' file.txt 还可以嵌套使用{}\n如：先匹配this，再匹配line，再执行d删除 sed '3,6 {/this/{/line/d}}' file.txt  ","description":"与awk结合非常强大。","id":6,"section":"posts","tags":["linux命令"],"title":"linux command -- sed","uri":"http://blog.nstop.cn/posts/linux/sed/"},{"content":"命令行快捷键 实用快捷键总览\n   快捷键 功能     ctrl a 移动到行首   ctrl e 移动到行尾   ctrl f 向右移动一位,代替左箭头   ctrl b 向左移动一位,代替右箭头   ctrl w 向左删除,直到遇到第一个空格为止   ctrl u 向左删除,一直删到头   ctrl k 向右删除,一直删到尾   ctrl h 向左删除一个字符,等价于backspace   ctrl d 删除光标处字符,如果整行没有一个字符,则相当于exit退出   ctrl r 输入关键字查找历史命令   ctrl j 等价于enter键   ctrl p 向前翻看历史命令   ctrl n 向后翻看历史命令    上表所有的快捷键能够更好的帮助你在终端移动光标以及删除命令\n 左移右移，通过ctrl + b(f)可以让你的双手不离开主键盘区 如ctrl + j 或者ctrl + h 可以代替enter键和backspace 快速定位命令行首或行尾，再也不要一位一位的去移动光标 ctrl + u 和 ctrl + k 可以快速地清除你不想要的命令行 试想一下，你在输入命令的时候，有时候是分几块的,\n而你通常是输错了最后一块,这时你无需一个一个地删  1 2 3 4 5 6 7  # 假设你在输入以下命令时，你发现你要查找路径写错了， # 只想把这路径重新改了, 这时ctrl w 派上用场了 grep -r \u0026#34;struct sockaddr_in {\u0026#34; /ussr/include # 按ctrl w grep -r \u0026#34;struct sockaddr_in {\u0026#34; # 接着输入正确的路径 grep -r \u0026#34;struct sockaddr_in {\u0026#34; /usr/include    ctrl r用来查找你前面使用过的命令，也许你还有点印象，只记得命令行中有个\ncat，那么你就可以用这个ctrl r，输入关键字cat，马上定位到你想要的那条历史命令  vim实用技巧  移动    说到移动,首先肯定会想到hjkl,可进行简单的移动,具有局限性。\n因为有时候我们并不想一个一个字符地去移动，这样太浪费时间了。\n  稍微快点的方法==单词间的移动\nw : 移动以单词为单位\nb ：移动到词头\ne ：移动到词尾\nge: 移动到上一个单词的尾部\n描述如图：\n  1 2 3 4 5 6  b\u0026lt;---b\u0026lt;-@---\u0026gt;w | | | prev current next | | | | ge\u0026lt;---@-\u0026gt;e---\u0026gt;e    f{char} 匹配某个字符来达到移动的目的, 这种方法比较推荐  1 2 3 4 5 6  # 假设有这么一段 void *thread_callback() { ... } # 我想将callback替换为cb # 按f + c 直接将光标移动到c # 然后dwi,输入b,\u0026lt;Esc\u0026gt;完成   用,和;来左右移动到相邻的字符匹配项,如图\n1 2 3 4 5 6 7  there is my bash, not shell ^ ^ ^ ^ fs---\u0026gt;\u0026gt;| | | ;----\u0026gt;\u0026gt;| | | ;-----\u0026gt;\u0026gt;| | |\u0026lt;\u0026lt;-----, |\u0026lt;\u0026lt;----,    t{char} 与f{char}类似，t{char}找到匹配项的前一个字符 T{char}和F{char} 与 t{char} 和 f{char}搜索方向相反  插入模式下的删除操作\nctrl h : 等价于Backspace\nctrl u : 从光标处开始删除,一直到行首\nctrl w : 从光标处开始删除,直至碰到往前数第一个空格  1 2 3 4 5 6  # 删除示例 this is a line ^ ^ | | | ctrl h | ---ctrl w -------------ctrl u   ctrl o : 进入Insert-normal模式(该模式下执行一条command之后自动退回Insert模式)\n有什么用？\n如：将当前光标所在行移至屏幕正中央,立马返回插入模式\n首先ctrl o 进入Insert-Normal模式,然后zz\n 命令模式下的内容块移动和复制\n:t(copy) 与 :m(move)\n格式：\n:[range]t{adress} 如:6t.则是将第6行的内容复制到当前光标所在行\n:[range]m{adress} 如1,5m$则是将第1行到第5行的内容移动到文本末尾\n在normal模式下不照样可以用yy和dd来达到类似的效果，为什么还要用这个？\n第一：yy和dd可以达到移动效果，但是需要来回的移动光标，而且还要输入两次命令\n第二：一般我们在编辑的时候，是秉持着尽量能不移动光标就不移动光标的原则\n相比之下，你就会发现这个技巧还是挺有用的\n  mark标记，可以让你来回地定点切换\n:mark [a-zA-Z]标记\n如 :mark m 将当前光标位置标记为m\n`m : 跳转到标记m处\n  应用场景：假设你正在查看某一代码区域，但这块区域有个函数调用，你想去看下这个\n函数定义,这时，你应该先标记当前位置，然后再跳转到函数定义处看逻辑处理,\n看完之后此时，你想快速地回到原来的位置，则直接用`标记即可快速跳转\n 写代码时用到的小技巧\n% : 可以来回地切换括号(和)以及花括号{和}, 常用于函数\ngf : 可以直接在引入头文件处输入gf, 即可跳转到头文件内\n= : 自动缩进当前行，如gg=G自动格式化整个文本，=G自动格式化当前行到文本\n末尾的代码区域\n\u0026gt;\u0026gt; : 向右缩进一个制表符\n\u0026lt;\u0026lt; : 向左缩进一个制表符\n在命令行和vim之间来回切换:\n假设你正在用vim编辑一段代码，突然有件特别重要的事需要处理，\n而且必须要在terminal下工作，这时你可以ctrl z来暂停当前vim\n进程，把它放到后台去。然后当你处理完紧急事件之后，你又想回来\n接着写代码，只需要输入fg把后台停止运行的vim恢复到前台工作即可。\n补充：\njobs 查看当前在后台执行的命令，可查看命令进程id\nnohup 在命令前加上nohup，退出终端也会在后台继续执行\nfg N 将命令进程id为N的命令进程放到前台执行，同%N\nbg N 将命令进程id为N的命令进程放到后台执行\n  可视模式\n这个模式就类似于你用鼠标去选中一块文本进行处理\nv : 横向选择文本块\nV(ctrl v): 纵向选择文本块\n可视模式下o: 切换控制左右限定边界线\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 假设有这么一段文本,你想把this都改为there, # 当然你首先肯定想到的是替换字符串:%s/this/there/g # 但你还可以用可视模式完成 ------------------------- this is a line; this is a line; this is a line; this is a line; this is a line; this is a line; ------------------------- # 将光标置于第一行第一列 # ctrl v 进入纵向可视模式 # j 下移到最后一行 # w 右移到单词末尾 # 按s或者c ---\u0026gt; 填入there ---\u0026gt; \u0026lt;Esc\u0026gt;退出Insert模式 # 这时你就可以看到整列单词全部替换为there # 你可能觉得我改的地方多了, # this和there的差别只是is和ere的区别 # 没错,我故意的,我想介绍一个绝技 # 你可以在可视模式下选择区域时, # 通过按 o 来切换控制左右限定边界线 --------------------------- # 还是上面的文本 # 将光标置于第一行第一列 # ctrl v 进入纵向可视模式 # j 下移到最后一行 # w 右移到单词末尾 # o 右边界线跳到左边界线 --\u0026gt; 将左边界线右移两位(ll) # 此时光标位于字符 i 上 # 按s或者c ---\u0026gt; 填入ere ---\u0026gt; \u0026lt;Esc\u0026gt;退出Insert模式 # 这时你同样可以看到整列单词全部替换为there   宏录制\n此功能非常强大,可以重复一系列动作,效率极高\n开始宏: q + 任意一个字符(这个字符作为宏名称)\n结束宏: 要想结束宏录制,直接在Normal模式下直接按q即可\n回放宏: @宏名字  演示: 输入1~100的数字，每个数字独占一行\n首先你得先了解两个组合键 ctrl a和ctrl x\nctrl a : 将光标处的数字进行加1操作\nctrl x : 将光标处的数字进行减1操作\n1 2 3 4 5 6 7  # q a 开始录制宏 # i --\u0026gt; 输入1 --\u0026gt; \u0026lt;Esc\u0026gt;退出Insert模式 # yyp --\u0026gt; ctrl a  # q 结束宏录制 # @a 回放宏 # @@ 回放上一次宏 # 98@@ 一步到位,重复98次   怎么样，举个小小的例子，领略到宏录制的风骚了吧！\n扩展：\n像类似这种重复操作的还有操作符.,这个也特别常用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 假设有这么一列数字，你想把它们都加1，怎么做？ # 当然前面的宏录制完全可以实现，但有点大材小用了 # 直接用`.`可以完美完成任务 --------------------------- 1 2 3 4 --------------------------- # 将光标移到数字1处，ctrl + a 将数字加1 # j 下移一位, 按.操作符重复刚才动作 # j. # j. # 完成任务   .用处很多,非常实用,自己去尝试摸索吧！\n另外还有个绝活哥: :[range]normal[command]\ncommand可以是任何Normal模式下的命令,它也能达到重复操作命令的效果\n如你想快速将全部文本注释掉\n:%normal I//直接了当，%代表全部的意思,\n像类似这种符号还有^(文本首行)和$(文本末行)和.(当前行)\n你可以跟替换字符串:%s/this/other/g比较着看\n还举一例：快速删除所有文本%normal dd\n另外还可以搭配宏功能来使用:\n如:.,$normal @a: 在当前行到文本末行的范围使用宏回放功能@a\n","description":"vim是否能体现它的强大是需要大量的练习和一些实用技巧的","id":7,"section":"posts","tags":["vim"],"title":"vim实用技巧和一些命令行快捷键","uri":"http://blog.nstop.cn/posts/linux/linux-vim/"},{"content":"linux用命令发送邮件  首先务必关掉本机上的邮箱服务器sendmail和postfix服务，显然通过登录到外来邮箱服务器来发送邮件比较好。 去你的邮箱首页设置中开启IMAP/SMTP 或者 POP3/STMP服务，拿到授权码。 打开/etc/mail.rc文件，在其后增加以下内容  set from=123456@qq.com # 你的邮箱账号 set smtp=smtp.qq.com # qq邮箱服务器的地址，你也可以用smtp.163.com(网易的) set smtp-auth-user=123456 # 你的qq号 set smtp-auth-password=runoob # 你的授权码 set smtp-auth=login  你可以用现有的文件email.txt发送  1  mail -s \u0026#34;title\u0026#34; ###@qq.com \u0026lt; email.txt    当然你也可以直接发一串字符  echo \u0026quot;hello world!\\n\\n\u0026quot; | mail -s \u0026quot;title\u0026quot; ***@163.com 阿里云服务器不能正常发邮件的解决办法   原因\n一般来说，SMTP服务的端口为25，但阿里云服务器限制了这个端口的开放。\n为什么要限制？呵呵！防止你利用它来群发垃圾邮件!\n  可以使用加密邮件，默认端口为465。\n  方法步骤\n    关掉现在主机上使用的sendmail和postfix服务，不使用本机上的邮件服务器。开放服务器端口465\n  安装mailx ====\u0026gt; yum install mailx -y\n  请求数字证书（将所有的文件全部放在家目录下的.certs文件里）\n  1 2 3 4 5 6 7 8 9 10 11 12  mkdir -p ~/.certs echo -n | openssl s_client -connect smtp.163.com:465 | \\ sed -ne \u0026#39;/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p\u0026#39; \u0026gt; ~/.certs/163.crt certutil -A -n \u0026#34;GeoTrust SSL CA\u0026#34; -t \u0026#34;C,,\u0026#34; -d ~/.certs -i ~/.certs/163.crt certutil -A -n \u0026#34;GeoTrust Global CA\u0026#34; -t \u0026#34;C,,\u0026#34; -d ~/.certs -i ~/.certs/163.crt certutil -A -n \u0026#34;GeoTrust SSL CA - G3\u0026#34; -t \u0026#34;Pu,Pu,Pu\u0026#34; -d ~/.certs/./ -i ~/.certs/163.crt certutil -L -d ~/.certs   配置/etc/mail.rc  1 2 3 4 5 6 7  set from=xxx@163.com #之前设置好的邮箱地址 set smtp=\u0026#34;smtps://smtp.163.com:465\u0026#34; #邮件服务器 set smtp-auth-user=xxx@163.com #之前设置好的邮箱地址 set smtp-auth-password=xxxx #授权码 set smtp-auth=login #默认login即可 set ssl-verify=ignore #ssl认证方式 set nss-config-dir=~/.certs #证书所在目录    需要注意的是.certs文件在哪个用户下，哪个用户就能发送邮件成功。\n 在c语言代码中使用mail命令发送邮箱 1 2 3  FILE *f = popen(\u0026#34;/usr/bin/mail -s \u0026#39;title\u0026#39; \u0026#39;xxx@163.com\u0026#39;\u0026#34;, \u0026#34;w\u0026#34;); char recv_name[BUFSIZ] = \u0026#34;zhangsan\u0026#34;; fprintf(f, \u0026#34;dear %s: \\n\\n\\thello world!\\n\u0026#34;, recv_name);   ","description":"如何在linux下用脚本发送邮件","id":8,"section":"posts","tags":["mail"],"title":"mail命令发邮件","uri":"http://blog.nstop.cn/posts/linux/linux-mail/"},{"content":"grep 查找文件内容\n1  grep \u0026#34;test\u0026#34; file.txt file1.txt    选项-n\n显示匹配内容所在行的行号  1  grep \u0026#34;test\u0026#34; file.txt file1.txt -n    选项-o\n只输出匹配到的文本,不会打印整行  1  grep -o \u0026#34;test\u0026#34; file.txt    选项-v\n反转，打印出除匹配内容所在行之外的内容  1  grep -v \u0026#34;test\u0026#34; file.txt    选项-c\n统计匹配内容行的行数, 注意如果一行中有多个\n匹配项，则只计数1次  1 2 3 4  grep -c \u0026#34;test\u0026#34; file.txt # 如果要统计某文本中匹配项的个数 grep -o \u0026#34;test\u0026#34; file.txt | wc -l    选项-l\n不会输出匹配内容，只会打印文件中含有匹配内容的文件名  1 2 3 4 5 6 7 8 9  cat file.txt test1test cat file1.txt adfjasajsdf grep -l \u0026#34;test\u0026#34; file.txt file1.txt # 输出 file.txt    选项-R/-r\n表示从目录路径[path]递归遍历查找  1 2  # 从当前目录向下遍历查找 grep -r \u0026#34;test\u0026#34; file.txt .    选项-i\n在匹配时不考虑大小写  1 2 3  echo hello world | grep -i \u0026#34;HELLO\u0026#34; # 输出 hello world    选项-E\n通过该参数使用正则表达式\n还可以直接用egrep  1 2 3 4 5 6 7  # 不使用-E参数需要转义一些特殊字符 grep \u0026#39;[0-9]\\{1,3\\}\u0026#39; data.txt # 使用-E grep -E \u0026#39;[0-9]{1,3}\u0026#39; data.txt # 等价于 egrep \u0026#39;[0-9]{1,3}\u0026#39; data.txt    选项-e\n指定多个匹配模式  1 2  # 匹配既有test又有ceshi内容的行 grep -e \u0026#34;test\u0026#34; -e \u0026#34;ceshi\u0026#34; file.txt    选项--include/--exclude\n在匹配过程中指定(include)和排除(exclude)某些文件  1 2 3 4  # 指定在当前目录向下遍历查找，并且只在c文件或cpp文件中查找 grep -r \u0026#34;main()\u0026#34; . --include *.{c,cpp} grep -r \u0026#34;def\u0026#34; . --exclude *.{c,cpp}    选项-A/-B/-C\n-A n: 显示匹配所在行的前n行内容\n-B n: 显示匹配所在行的后n行内容\n-C n: 显示匹配所在行的前后各n行内容  1 2 3  # 想知道某个结构体在哪个头文件中有定义 # 直接在terminal中显示结构体的定义, 无需再去打开 grep -r -n \u0026#34;struct sockaddr_in {\u0026#34; /usr/include -C 10   ","description":"查文件内容常用命令","id":9,"section":"posts","tags":["linux命令"],"title":"linux command -- grep","uri":"http://blog.nstop.cn/posts/linux/grep/"},{"content":"检查编译器是否支持c++11 1 2 3 4 5 6 7 8 9 10 11  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { //c++98：199711  //c++11: 201103  cout \u0026lt;\u0026lt; __cplusplus \u0026lt;\u0026lt; endl; retrurn 0; }   defalut \u0026amp;\u0026amp; delete  =default的使用\n一般设计一个空类，编译器会默认为其生成默认的构造函数，默认的析构函数，\n默认的拷贝构造，默认的拷贝赋值，如果自定义写出了自己的版本，那么编译器将不再生成默认的以上函数。\n假设既想有自己版本的构造函数，又想要编译器提供默认的构造函数，那么可以这么写  1 2 3 4 5  class Foo{ public: Foo()=default; Foo(int a); };    注意：一个类中只允许存在一个拷贝构造（拷贝赋值、析构函数）\n  =delete\n将默认的版本禁用（删除）\n好像不太常用，那什么时候用这个关键字呢？   在设计单例模式的时候应该要用到=delete, 单例模式中在整个运行过程中只允许出现一个该对象，\n也就是说要约束该类型对象的创建。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class single{ public: //由于编译器会生成默认的拷贝构造和拷贝赋值，所以应该禁用掉，避免通过其创建对象 \tsingle(const single\u0026amp;) =delete; //这里可写可不写，因为不存在拷贝构造，也就是只会存在一个该类型的对象 \t//由于拷贝赋值需要两个对象（=左右两边），那么拷贝赋值是永远用不到的。 \tsingle\u0026amp; operator=(const single\u0026amp;) =delete; static single *ptr; static single *getInstance() { if (ptr == nullptr) ptr = single(); return ptr; } private: single() { } //将构造函数设置成私有，这样就足够了？ }; single *single::ptr = nullptr;   auto  auto 能根据等号右边的变量（或者是函数或者是表达式或者是字面值常量）来自动推导类型   Using auto is especially useful where the type is a pretty long and/or complicated expression.\n使用auto主要是用来替代那些太长的类型名，使代码比较简洁。\n  比较复杂的类型或者说是比较长的类型名有哪些呢？  1 2 3 4 5 6 7 8  //使用类模板中的类型 vector\u0026lt;string\u0026gt; vec; auto it = vec.begin(); // 用 auto 替代 vector\u0026lt;string\u0026gt;::iterator 使代码显得更加简洁  //使用lambda表达式使用auto最好不过 auto res = [](int val)-\u0026gt;bool { ... }    另外在用range for statement（范围for语句）时经常用到auto  1 2 3 4  vector\u0026lt;int\u0026gt; vec {1, 2, 3, 4}; for (auto i : vec) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }    auto注意事项  1 2 3 4 5 6 7 8 9 10 11 12 13  int i, \u0026amp;val = i; auto a = val; // a 是一个整数(auto是根据val引用的对象i来推导类型的) auto P = \u0026amp;i; // p 是一个整型指针  const int ci = i, \u0026amp;cr = ci; auto b = ci; // b 是一个整数（顶层const的限制被忽略） auto c = cr; // c 是一个整数（首先auto根据cr引用的对象ci推导出const int 类型，但const限制被忽略 auto d = \u0026amp;ci; // d 是一个指向整型常量的指针（底层const限制没有被忽略）  const auto e = ci; // e 是一个整型常量 auto \u0026amp;g = ci; // g 是一个整型常量引用 //auto \u0026amp;h = 42; //error! 不能为非常量引用绑定字面值 const auto \u0026amp;j = 42; // 可以为常量引用绑定字面值   decltype   decltype 根据对象来返回对象对应的类型\n  used to declare return types\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  template \u0026lt;typename T1, typename T2\u0026gt; ？add(T1 x, T2 y) { return x + y; } // 怎么确定add函数的返回类型呢  //这时可以想到decltype, 利用decltype根据 x + y 得到的结果来推导返回类型 decltype(x + y) add(T1 x, T2 y) { return x + y; } // 这样做真的可以吗？error: 由于在使用decltype(x + y)之前没有x 和 y的定义，编译器报错  // 那怎么办呢？...  // 结合auto来使用decltype auto add(T1 x, T2 y) -\u0026gt; decltype(x + y) { return x + y; }     在类模板中使用decltype来获得传入参数的类型\n  used to pass the type of a lambda\n  1 2 3 4 5  auto cmp = [](const Person\u0026amp;p1, const Person\u0026amp; p2) { return p1.age \u0026lt; p2.age; }; // 使用lambda表达式得到的结果只是一个object，并不知道其类型。decltypee就派上用场了 std::set\u0026lt;Person, decltype(cmp)\u0026gt; coll(cmp);   explicit 显示转换  explicit会抑制类型的隐士转换 explicit for ctors taking more than one argument (c++2.0新特性之前)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt; using namespace std; struct Foo { int a, b; // 如果在构造函数之前加上explicit关键字，Foo g = f + 4; 这句无法编译通过 \tFoo(int a, int b = 0) { cout \u0026lt;\u0026lt; \u0026#34;call constructor\u0026#34; \u0026lt;\u0026lt; endl; } Foo operator+(const Foo\u0026amp; obj) { return Foo(a + obj.a, b + obj.b); } }; //=======================================================================// Foo f(1, 2); Foo g = f + 4; // 4 会隐士转换为Foo类型的对象    explicit for ctors taking more than one argument (c++2.0新特性)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: // 如果在构造函数之前加上explicit关键字,则关闭自动隐士转换的功能。 \tA(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;call A(int,int), a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } }; //=======================================================================// A a[]{{2, 3},{4, 5}}; //{2, 3}、{4, 5} 都会隐士转换为A类型的对象    lambda  lambda最简模式  1 2 3 4 5 6 7 8  []{ cout \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl; } //也可以直接调用 []{ cout \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl; }(); // lambda表达式类似仿函数，lambda基本上都能用仿函数来表示    lambda格式\n[函数对象参数](函数参数) mutable 或 exception -\u0026gt; 返回值类型{ 函数体 }  1 2 3 4  int x = 1; auto l = [x](int y)-\u0026gt;int { return x + y; };    函数对象参数说明\n[] 不能操作任何外部作用域中的object\n[=] 拷贝一份外部作用域中所有的变量以供在lambda表达式中使用。\n[\u0026amp;] 引用外部作用域中所有的变量以供在lambda表达式中使用。\n[=,\u0026amp;foo] 拷贝外部作用域中除foo变量以外的所有的变量，引用foo变量。\n[bar] 拷贝外部作用域中的bar变量。\n[this] 可以使用当前类中的this指针。如果使用\u0026amp;或者=就默认添加此项。  1 2 3 4 5 6 7 8 9 10 11 12  int a = 0; auto l = [a](int b) { a += b; //报错，没有加mutable关键字，不能修改a的值 }; auto m = [a](int b)mutable { a += b; //虽然修改了a，但外部作用域的a变量值仍然不变 }; auto n = [\u0026amp;a](int b) { a += b; //传的是引用，则a值修改成功 }   typename  typename这个关键词主要有下面几种用途\n  用在模板参数处  1 2 3 4 5 6 7 8 9 10 11  // 如类模板 template \u0026lt;typename T\u0026gt; class A {}; // 函数模板 template \u0026lt;typename T\u0026gt; void func(T x) { } // 包括可变参数模板 template \u0026lt;typename... T\u0026gt; void func(T... args) { }    用在使用某类中的类型处  1 2 3 4 5 6 7  template \u0026lt;typename Container\u0026gt; void test(Container c) { // 为什么要用typename？ \t// 由于Container::iterator 出现了 :: 符号, 这就意味着这个value_type到底是静态变量呢？还是Container中的一种类型呢？ \t// 所以为了解决歧义，就在前面加上typename以表示这是一种类型 \ttypedef typename iterator_traits\u0026lt;typename Container::iterator\u0026gt;::value_type Valtype; }    标准模板库源码中很多地方都用到了重命名类型这个语法\n type alias   在引用命名空间时使用using\nusing namespace std; // 如果不想频繁地使用std::\nusing namespace std::cout; // 使用cout时不需要再指定命名空间了\n  Alias Template（取别名，带模板参数的）\n  1 2 3 4 5 6 7 8 9 10 11 12 13  template \u0026lt;typename T\u0026gt; using myvector = std::vector\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt;; //用myvector来代替后面的类型  //使用myvector定义变量 myvector\u0026lt;string\u0026gt; v; //#define 能达到上述这种效果吗？显然不能 #define myvector \\ template \u0026lt;typename T\u0026gt; using myvector = std::vector\u0026lt;T, MyAlloc\u0026lt;T\u0026gt;\u0026gt;  //typedef 能吗？不能，typedef重命名的类型不能携带模板参数 //用typedef只能具体到某一种类型，不具有using那样的扩展性 typedef myvector = std::vector\u0026lt;string, MyAlloc\u0026lt;string\u0026gt;\u0026gt;;    Alias Template的作用不仅仅只是为了简化类型名称而为定义object带来方便。\n最重要的是它主要应用于模板模板参数。\n  模板模板参数，即模板中的模板参数又是一个模板  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  //当第二个模板参数中的模板参数只有一个时，可以省略 //即可写成这样 template \u0026lt;typename T, template \u0026lt;class\u0026gt; class Container\u0026gt; template \u0026lt;typename T, template \u0026lt;class Type\u0026gt; class Container\u0026gt; class Example{ private: Container\u0026lt;T\u0026gt; c; }; // Alias Template template \u0026lt;typename T\u0026gt; using myvector = vector\u0026lt;T, allocator\u0026lt;T\u0026gt;\u0026gt;; int main(){ //创建对象 \tExample\u0026lt;string, ?\u0026gt; e;\t// ?处填什么呢  Example\u0026lt;string, vector\u0026gt; e;\t// 可以这样写吗？ \t// 编译器报错 error: Template template argument has different template \t// parameters than its corresponding template template parameter \t// 解释：说vector这个模板类需要的模板参数个数和Example第二个参数需要的模板参数个数不匹配 \t// 通俗地说就是vector是需要两个模板参数的。虽然我们平常使用vector时只需要提供一个模板参数， \t// 但是其实还有一个默认的模板参数。而Example类的模板模板参数只要提供一个，因此不符。  Example\u0026lt;string, myvector\u0026gt; e; //正确写法，用到了Alias Template（这才是它的主要用途）  // 那可不可以这样写呢？ \tExample\u0026lt;string, vector\u0026lt;string, allocator\u0026lt;string\u0026gt;\u0026gt; e; // 不行, 为什么？ \t// 因为Example第二个参数是接受一个模板模板参数，而不是一个具体的类型，是需要一个带模板参数的类型（不定的） }    Type Alias (类型别名)  1 2 3 4 5 6 7  //声明一个函数指针类型 using func = void (*)(int); // 等价于 typedef void (*func)(int)  template \u0026lt;typename T\u0026gt; struct Container{ using value_type = T; // 等价于 typedef value_type = T; }   Variadic Template(可变模板参数)  可变参数模板，顾名思义，可以接受任意个任意类型的参数，想想就令人感到震惊。\nfor example: 打印传入参数  1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt; using namespace std; //必须要实现 void print() { } template \u0026lt;typename T, typename... Types\u0026gt; void print(const T\u0026amp; firstArg, const Types\u0026amp;... args) { // 将n个参数分为1+n个 \tcout \u0026lt;\u0026lt; firstArg \u0026lt;\u0026lt; endl; //递归调用自身，但当args为0个参数时就会调用到重载版本void print() \tprint(args...); }      试想加入以下重载版本，到底会调用哪一个呢？\n   1 2 3 4 5  //这个是相对泛化，而上面那个是特化版本(因此与上面重载版本共存时，这个泛化版本永远不会被调用) template \u0026lt;typename T, typename... Types\u0026gt; void print(const Types\u0026amp;... args) { cout \u0026lt;\u0026lt; sizeof...(args) \u0026lt;\u0026lt; endl; //sizeof...可以求得args的个数 }    tuple 的实现就用了以上两个版本，一个泛化，一个特化。\n 右值与move语意   右值引用\n什么是右值？只能出现在=右边的值称为右值。一个字面值常量就是右值, 临时对象也是一个右值。\n例如：6 = 9; error: 6不能当做左值\nint a = 0, b = 1; a + b = 6; error: 表达式不能做左值\n右值引用：只能对右值引用。\n例如：int \u0026amp;\u0026amp;a = 6; 但是 int b = 5; int \u0026amp;\u0026amp;a = b; error: b为左值\n  move\n  1 2 3  int b = 5; int \u0026amp;\u0026amp;a = move(b); // 当明确b以后不再被使用时，可以用move把b转换成右值。     容器中对移动拷贝构造和移动赋值运算符的运用\n像vector、deque这两种容器，当存放元素个数大于容器原容量，会扩增容量，\nvector会以原容量的2倍增长，它会另外分配一块内存空间，\n然后将原空间的元素依次拷贝到新空间中去。这就涉及到了元素的拷贝构造函数。\n而deque容器，如果往其中间插入元素且原，那势必也会涉及元素的拷贝。\n由于大量的拷贝动作，这必然会带来效率上的问题。有可能在某种特殊业务场景，不需要去\n执行复杂的拷贝构造或者拷贝赋值。\n因此c++11引入了移动构造和移动赋值运算符来解决上述的问题。\nfor example: move.cpp\n  右值引用在传递过程中丢失信息\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  void func(int\u0026amp;\u0026amp; a) { cout \u0026lt;\u0026lt; \u0026#34;func(int\u0026amp;\u0026amp; a) is called\u0026#34; \u0026lt;\u0026lt; endl; } void func(const int\u0026amp; a) { cout \u0026lt;\u0026lt; \u0026#34;func(const int\u0026amp; a) is called\u0026#34; \u0026lt;\u0026lt; endl; } void forward(int\u0026amp;\u0026amp; a) { cout \u0026lt;\u0026lt; \u0026#34;forward(int\u0026amp;\u0026amp; a) is called\u0026#34; \u0026lt;\u0026lt; endl; func(a); } // ============== forward(6); // result: // forward(int\u0026amp;\u0026amp; a) is called // func(const int\u0026amp; a) is called // 由此得知在由forward函数传递右值时，右值又变为左值。   initializer_list(初始化列表)  **initializer_list\u0026lt;\u0026gt;**是标准库中的一个类模板，它可以接受不定个数的相同类型的参数  For example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;iostream\u0026gt;#include \u0026lt;initializer_list\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; void print(initializer_list\u0026lt;T\u0026gt; list) { for (auto it = list.begin(); it != list.end(); it++) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int main() { print({1, 2, 3, 4, 5, 6}); cout \u0026lt;\u0026lt; endl; print({\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;list\u0026#34;}); cout \u0026lt;\u0026lt; endl; return 0; }    用大括号来初始化object  1 2  int a[] {1, 2, 3, 4, 5}; vector\u0026lt;string\u0026gt; v{\u0026#34;how\u0026#34;, \u0026#34;are\u0026#34;, \u0026#34;you\u0026#34;};    分析：\n{x1, x2, x3, x4} 这种形式编译器会将其看做一个initializer_list, 而initializer_list内部中有一个array\u0026lt;T,n\u0026gt;, n代表个数。\n编译器会将列表中的参数逐一分解传给object对象的构造函数来初始化。\n如果是容器的话，容器中基本上都有一个带initializer_list参数类型的构造函数，因此不会执行前面的分解操作，直接传initializer_list这个参数来调用相应的构造函数。\n  针对以上的分析做一个测试  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class A { public: A(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;call A(int,int), a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } A(initializer_list\u0026lt;int\u0026gt; il) { cout \u0026lt;\u0026lt; \u0026#34;call A(initializer_list\u0026lt;int\u0026gt;), \u0026#34;; for (auto i : il) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } }; A a(2, 3);\t// 调用A(int, int) A b{2, 3};\t// 调用A(initializer_list\u0026lt;int\u0026gt;) A c{2, 3, 4}; // 调用A(initializer_list\u0026lt;int\u0026gt;) A d = {2, 3}; // 调用A(initializer_list\u0026lt;int\u0026gt;) A e({2, 3});\t// 调用A(initializer_list\u0026lt;int\u0026gt;) , 若没有该构造函数则会报错  // 假设没有带initializer_list的构造函数，则A c{2, 3, 4}会报错    用一个空大括号来为object设初值  1 2  int i{}; // i初始化为0 char *p{}; // p 初始化为nullptr    当初始化列表中的值类型范围小于object类型范围时，使用{}会报错。\nnarrowing initializations are not possible with braces.（c++标准规定）  1 2 3  int x1(5.3); // 用小括号可以成功初始化 int x2{5.3}; // error 由于大括号中的5.3是double类型，范围大于int类型。(在gnuc编译器下测试只是给出警告) char c1{128} // error char的取值范围为-128~127，而128超过了char的范围。(在gnuc编译器下只是给出警告)   override \u0026amp;\u0026amp; final \u0026amp;\u0026amp; noexcept  noexcept  1 2 3 4 5  // 在函数声明后加上noexcept，即告诉编译器这个函数处理保证不会出现异常 void func() noexcept { } // 等价于 void func() noexcept(true) { } // 也可以这样用 void func() noexcept(noexcept(func1())) { } //在保证func1执行过程中不出异常的情况下，那么func在调用过程中就不会出异常    override\n很多时候我们在重写父类的虚函数时，往往由于粗心而导致子类与父类的虚函数格式不一致，但此时编译器又不提供检查机制，这有点令人不满！\nc++11引入了override关键字就解决了这个问题。  1 2 3 4 5 6 7 8 9 10  class A { public: virtual void func() { } }; class B : public A{ public: virtual void func() override { }\t// 编译器提供检查机制 \tvirtual void func(int) override { }\t// error };    final  1 2 3 4 5 6 7 8 9 10 11  // 用在类名后 class A final { }; // A 不能再被继承  class Base { //用在虚函数后 \tvirtual void fun() final; // 不允许被子类重写 }; class B : public Base { virtual void fun() { } // error };   ","description":"小结modern c++","id":10,"section":"posts","tags":["c++11"],"title":"c++11一些新特性","uri":"http://blog.nstop.cn/posts/cpp/cpp11/"},{"content":"class class 与 struct 的区别 class 与struct的默认访问权限不同。class 默认访问权限是private，struct 默认访问权限是public\n计算类的大小 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class A { }; class B { private: int a; char b; }; class C { public: virtual ~C() { } }; sizeof(A); // 1 sizeof(B); // 8 (内存字节对齐) sizeof(C); // 8 (多一个虚指针) 64位机器上   构造、析构函数 一个空类，编译器会为其生成一个默认构造、默认拷贝构造、默认赋值运算符、默认析构函数。\n 构造函数中的初始值列表  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class A { private: int i; int j; public: A() = default; // 成员初始化顺序必须与它们在类定义中的顺序保持一致 \tA(int x, int y) : i(x), j(y) { }\t// 初始化(尽量写成这种形式) \t// A(int x, int y) { i = x; j = y} // 在初始化完之后才赋值 \t// 虽然都达到了同样的效果，但过程却不同，一个是初始化，一个是赋值  // 只有构造函数和拷贝构造函数才能用初始值列表 }; // A a(); // error: 这是一个函数声明，而非创建对象 A a;\t// 这才是用默认构造函数创建对象的正确方式    虚析构函数  当一个class with pointer(带有指针的类), 在它定义之后有子类继承，这时应为其基类声明虚析构函数\n如果不这样做，那么会出现以下这种情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class A { private: char *data; public: ~A(); }; class B : public A { }; //============ A *p = new B(); delete p; // 这时调用的是基类的析构函数，无法调用到子类定义的析构函数，有可能造成内存泄漏。   访问控制 三种访问限制符：public、protected、private。\n定义在public之后的成员允许在整个程序内被访问\n定义在private之后的成员可以被类的成员函数访问, 但不能在使用该类的代码处被访问\n定义在protected之后的成员允许被子类的成员函数访问\n静态成员和非静态成员 static 成员也有访问权限，可被修饰为public、private、protected。\nstatic 成员在类内部声明，在类外部定义。\nstatic 变量既能被静态函数访问，也能被非静态函数访问\nnon-static 变量只能被non-static function 访问\n1 2 3 4 5 6 7 8 9  class A { public: static int a; char b; }; int A::a = 0; sizeof(A); // 1 只计算non-static成员的大小   友元类和友元函数 通过友元类和友元函数可以访问到类的非公有成员\n最好在类定义开始或结束的时候声明友元。\n1 2 3 4 5 6 7 8 9 10 11 12  class A { friend void func(const A\u0026amp;, const A\u0026amp;); // 类内声明  friend class B; private: }; void func(const A\u0026amp; x, const A\u0026amp; y) { ... };   纯虚函数 一但类中存在纯虚函数，则该类不能被实例化, 包括没有重写纯虚函数的子类也不行\n具有纯虚函数的类称为抽象类。\n1 2 3 4  class A { public: virtual void func() = 0; // 未定义，等着子类来实现 };   const修饰的成员函数 成员函数后加上const关键字，修饰的是this指针，也就是const对象也能调用该成员函数\n常量版本的成员函数既可以被常量对象调用，又可以被非常量对象调用。\n常量版本和非常量版本成员函数可以共存。（也就是可以当做重载）\n共存时，常量对象会调用常量版本，非常量对象会调用非常量版本，并不会选择常量版本。\n1 2 3 4 5 6 7 8 9 10  class A { public: // 当在成员函数后加上const, 返回的是const 对象, 不能用非常量引用来绑定常量对象。 \t// A\u0026amp; func() const { return *this; } // error \tconst A\u0026amp; func() const { return *this; } // 常量版本 \tA\u0026amp; func() { return *this; } // 非常量版本 构成重载  A\u0026amp; func(const A\u0026amp; obj) { ... } // 既可以接受常量参数对象，也可以接受非常量对象参数。 \tA\u0026amp; func(A\u0026amp; obj) { ... }\t// 同样可以共存 };   内联函数 内联函数可以避免函数调用时的开销\n将函数指定为inline，则会在每个调用点内联展开，提高执行效率。\n为函数加上关键字则只是向编译器提供建议，至于能不能变为内联函数具体要看编译器。\n定义在类内部的成员函数是自动内联的。\n操作符重载 操作符重载是类设计中较重要的环节，主要以下几种  解引用（*) 成员访问运算符（-\u0026gt;) prefix or postfix increment and decrement （递增递减运算符） 关系运算符（==、!=、\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=) 算术运算符（+、+=、-、-=) 赋值运算符（=）函数调用运算符（()） 输入运算符（\u0026gt;\u0026gt;）输出运算符（\u0026lt;\u0026lt;）  迭代器中的操作符重载 迭代器就像一根智能的指针，指针有的操作它同样也得有\n一些重复利用技巧：\n 像前置和后置递增和递减  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // prefix Iterator\u0026amp; operator++() { ... } Iterator\u0026amp; operator--() { ... } // postfix(利用占位符区分prefix) Iterator operator++(int) { Iterator tmp = *this; ++*this; //直接用prefix来实现 \treturn tmp; } Iterator operator--(int) { Iterator tmp = *this; --*this; //直接用prefix来实现 \treturn tmp; }    +=和+与-=和-  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  Iterator\u0026amp; operator+=(difference_type n) { ... } Iterator\u0026amp; operator-=(difference_type n) { ... } Iterator operator+(difference_type n) { Iterator tmp = *this; return tmp += n; // 直接借用operator+= } Iterator operator-(difference_type n) { Iterator tmp = *this; return tmp -= n; // 直接借用operator-= } bool operator==(const Iterator\u0026amp; x) const { ... } bool operator!=(const Iterator\u0026amp; x) const { Iterator !(*this == x); // 借用operator== }   函数模板   函数模板的使用   1 2 3 4 5 6 7 8 9 10 11 12  template \u0026lt;typename T1, typename T2, 。。。\u0026gt; //可用多个参数，但无论声明了多少个都必须全部使用 //注意：typename可用class替换 void sort(T1 \u0026amp;a, T2 \u0026amp;b){ ... } // 调用模板函数： // 显示调用： sort\u0026lt;int, char\u0026gt;(a, b) // 自动类型转换调用： sort(a,b)     函数模板与普通函数在一起使用时的调用规则  普通函数可以隐式地转换类型，而函数模板会严格匹配类型 在既满足普通函数的调用，又满足函数模板的调用的情况下，编译器会优先选择调用普通函数 如果强制要选择函数模板，则可以使用空模板实参列表来限制 如sort\u0026lt;\u0026gt;(a,b); 模板函数支持重载（同普通函数重载的原则一样） 如果函数模板可以产生一个更好的匹配，则会选择模板    函数模板本质剖析  gcc编译器编译过程：预处理 ==\u0026gt;编译 ==\u0026gt; 汇编 ==\u0026gt;链接 编译器对函数模板的处理：\n(1) 编译器不会对函数模板编译产生满足要求的所有类型的函数\n(2)编译器会根据具体类型来编译不同的函数\n(3)编译器会进行二次编译\n第一次是在不确定类型的情况下对模板进行初步编译\n第二次是在调用函数时已经确定了类型时编译（同一种类型只编译一次）    智能指针 shared_ptr  多个shared_ptr可以同时共享一个对象, 其中采用了引用计数的方式。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 初始化shared_ptr shared_ptr\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; p; // 指向vector\u0026lt;string\u0026gt;对象的指针, 此时为空  // 用auto 替代 shared_ptr\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; auto p1 = make_shared\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;(); // p1指向一个空vector  // 用new 创建的对象作为参数来实例化一个shared_ptr auto p2 = shared_ptr\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;(new vector\u0026lt;string\u0026gt;); shared_ptr\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; p3(new vector\u0026lt;string\u0026gt;); p1 = p2; // 递增右边shared_ptr的引用计数，递减左边shared_ptr的引用计数 // 当引用计数为0时，释放动态对象。  *p1 // 解引用p，获得它指向的对象 p1.get(); // 获得p中保存的指针，慎用。不要用它来初始化另一个智能指针或为其赋值。 // 当你使用p1.get()时，你不知道它何时会被释放掉  p.unique(); // 判断p的引用计数是否为1  p.use_count(); // 返回p的引用计数，反应可能很慢，该函数主要用来调试     智能指针比一般指针安全  1 2 3 4 5 6 7 8 9 10 11 12  void fun() { shared_ptr\u0026lt;int\u0026gt; sp(new int(42)); // ... 抛出异常，而且异常并未被捕获 \t} // 离开作用域时依然能正常释放内存  void fun() { int *p = new int(42); // ... 抛出异常，而且异常并未被捕获 \t// 由于在这过早结束函数调用，来不及释放内存 \tdelete p; }    可自选删除器  1 2 3 4 5 6 7 8 9  class connection { ... }; void end_connection(connection *p) { disconnection(*p); } // 当delete释放connection对象时，不会调用它默认的析构函数，而是传入的函数end_connection(也可以是函数对象) shared_ptr\u0026lt;connection\u0026gt; p(new connection(), end_connection);    智能指针使用时的注意事项  1 2 3 4 5 6 7 8 9 10 11 12  void process(shared_ptr\u0026lt;int\u0026gt; ptr) { ... } int *x(new int(42)); process(shared_ptr\u0026lt;int\u0026gt;(x)); // 传参是临时对象，在函数调用结束后自动释放它指向的内存空间 int j = *x; // error: 内存已被释放，无法再访问x指向的地址空间  // 用reset将智能指针重新指向新的内存空间 if (!p.unique()) // 先判断是否只有自己独享这块内存空间 \tp.reset(new string(*p)); //如果不是，就新分配一块内存空间，同样根据原则更新各自的引用计数 *p += newVal; // 此时脱离了共享的区域，创建的新区域可以随意修改，不会再影响原来的那块内存空间   unique_ptr  只能有一个unique_ptr拥有同一块内存空间，不能共享, 也就没有相应的拷贝和赋值操作  1 2 3 4  unique_ptr\u0026lt;int\u0026gt; p1(new int(20)); unique_ptr\u0026lt;int\u0026gt; p2(p1); // error: 不能拷贝 unique_ptr\u0026lt;int\u0026gt; p3; p3 = p1; // error: 不能赋值    虽然不能拷贝和赋值，但可以通过release或reset来转移指针的所有权  1 2 3 4 5  unique_ptr\u0026lt;string\u0026gt; p1(new string(\u0026#34;abcd\u0026#34;)); unique_ptr\u0026lt;string\u0026gt; p2(p1.release()); // p1置空，p2指向了原来p1指向的空间 unique_ptr\u0026lt;string\u0026gt; p3(new string(\u0026#34;hello\u0026#34;)); p2.reset(p3.release()); // p3置空，p2释放了原来的空间，又指向了p3原来指向的空间     特殊的\u0026quot;拷贝\u0026quot;和\u0026quot;赋值\u0026quot;  1 2 3 4 5 6 7 8 9 10  // 但是在以下特殊情况下，可以进行\u0026#34;拷贝\u0026#34; 和 \u0026#34;赋值\u0026#34; (其实是调用移动拷贝和移动赋值) unique_ptr\u0026lt;int\u0026gt; clone(int p) { return unique_ptr\u0026lt;int\u0026gt;(new int(p)); // 返回临时对象(右值) } unique_ptr\u0026lt;int\u0026gt; clone(int p) { unique_ptr\u0026lt;int\u0026gt; ret(new int(p)); return ret; // 返回局部对象(离开作用域就销毁) }    同样unique_ptr也有可选的删除器(但与shared_ptr不同)  1 2  // 在delete时，会调用delt类型的名为fcn的函数对象 unique_ptr\u0026lt;objT, delT\u0026gt; p(new objT, fcn);   weak_ptr 可以与shared_ptr指向同一块内存空间, 但不会改变引用计数。\n1 2 3 4 5 6 7 8  // 创建weak_ptr时需要用一个shared_ptr来初始化它 auto p = make_shared\u0026lt;int\u0026gt;(42); weak_ptr wp = p; // 在使用weak_ptr时，由于对象可能不存在, 需要用lock先判断对象是否存在 if (shared_ptr\u0026lt;int\u0026gt; np = wp.lock()) { // 如果np 为空, 则跳出if \t// np 与 p 共享对象 }   对象关系 对象关系分为inheritance(继承)、composition(组合)、delegation(委托),\n也有些人把它分为继承和组合，组合和委托放在一起\n inheritance  1 2 3 4 5 6 7  class A{ }; // 公有继承（形式上表现为 is a 的关系） class B : public A{ }; // 私有继承（形式上表现为 has a 的关系） class C : private A{ };    composition  1 2 3 4 5 6  class E { }; class F { // 有一个E类对象成员 \tE e; };    delegation  1 2 3 4 5 6  class E { }; class F { // 有一个指向E类对象的指针, 与组合不同的地方 \tE* e; };    当类中既有继承关系又有组合关系时，构造和析构的调用顺序是怎样的呢？  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: // 调用构造函数时先初始化a \tA() : a() { cout \u0026lt;\u0026lt; \u0026#34;执行A的构造函数\u0026#34; \u0026lt;\u0026lt; endl; } A(int x) : a(x) { cout \u0026lt;\u0026lt; \u0026#34;执行A的有参构造函数\u0026#34; \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;执行A的析构函数\u0026#34; \u0026lt;\u0026lt; endl; } // 访问控制设为protected, 保证在子类内部可以访问到基类的a protected: int a; }; ## 四种类型强制转换  * **强制类型转换的格式** `cast-name\u0026lt;type\u0026gt;(expression)` `type`: 转换的目标类型, 如果为**引用**类型, 则转换结果为**左值**; `expression`: 要转换的值; `cast-name`: **static_cast**、**const_cast**、**dynamic_cast**、**reinterpret_cast** * **static_cast** \u0026gt; 只要不包含**底层const**，都可以使用**static_const**来强转类型 \u0026gt; 那什么是底层const呢？for example: `const char *p = a;` 这就是底层const，通过p指针不能修改a的值 \u0026gt; 那什么是顶层const呢？for example: `const int a = 0;` 这便是顶层const, a是常量，不可变更其值 ```c++ // 避免损失精度, 可以请出static_cast int i = 5, j = 3; double slope = static_cast\u0026lt;double\u0026gt;(i) / j; // 指针类型匹配 double a = 9.0; void *p = \u0026amp;a; // void* 可以指向任何类型的变量 double *dp = static_cast\u0026lt;double*\u0026gt;(p); // 将void* 转换为double*, 不同于c语言（直接用`(double*)`强转）    const_cast   只能改变运算对象的底层const\n 1 2 3 4 5  const char *pc; char *p = const_cast\u0026lt;char*\u0026gt;(pc); // 但是通过p指针写值是未定义的。  // 也就是说通过const_cast转型之前，你应该明确以后p指针是不会进行以下操作的 // *p = \u0026#39;a\u0026#39;; // error: undefine    reinterpret_cast   通常为运算对象的位模式提供较低层次上的重新解释。what？什么意思？不懂。\n举个例子:\n 1 2 3 4 5 6 7 8 9  // int* 指针的步长是4个字节（32位机器上）, char* 的步长是1个字节， // 所以可以用reinterpret_cast 将 int* 转换为 char* int *ip; char *pc = reinterpret_cast\u0026lt;char*\u0026gt;(ip); // 如果不知道会进行下面操作的话，这种情况就相当于安插了个定时炸弹  // 当进行如下操作时就直接发生运行时错误 string str(pc); // 其实就是在躲避编译器的检查（编译时检查）,因此使用该强转应该对类型转换之后的操作过程相当了解。    dynamic_cast   有如下三种转换形式\n dynamic_cast\u0026lt;type*\u0026gt;(e) // e必须是一个有效的指针, e的类型可以是type的公有派生类或者基类或者type\ndynamic_cast\u0026lt;type\u0026amp;\u0026gt;(e) // e必须是一个左值\ndynamic_cast\u0026lt;type\u0026amp;\u0026amp;\u0026gt;(e) // e必须是右值\n   类之间应该有继承关系，并且含有虚函数\n第一种转换失败会返回0，第二种和第三种转换失败会抛出bad_cast异常\n 主要用于RTTI（运行时类型识别），dynamic_cast 与 typeid 结合使用\n typeid包含在typeinfo头文件中，它可以根据表达式判断运行时类型。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Base { public: virtual ~Base() { } }; class Child : public Base {}; Base *pp = new Child; Child *pc = new Child; if (typeid(*pc) == typeid(*pp)) { cout \u0026lt;\u0026lt; \u0026#34;pc 和 pp 指向的对象类型相同\u0026#34; \u0026lt;\u0026lt; endl; } if (Child *np = dynamic_cast\u0026lt;Child*\u0026gt;(pp)) { // 如果转换失败返回0，跳出if \t... } void f(const Base\u0026amp; b) { try { const Child \u0026amp;c = dynamic_cast\u0026lt;Child\u0026amp;\u0026gt;(b); } catch (bad_cast) { // 处理异常 \t} }    建议：不要轻易使用强制类型转换，尽可能避免。  new \u0026amp;\u0026amp; delete 动态分配内存的时候需要用到这两个关键字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class A {}; // 先调用全局函数(::operator new(size_t)) // 再调用A的默认构造函数 A *pA = new A(); // 先调用A的析构函数， // 再调用全局函数(::operator delete(void *)) delete pA; // 先调用全局函数(::operator new[](size_t)) // 再依次调用10次A的默认构造函数 A *pArray = new A[10]; // 先依次调用10次A的析构函数， // 再调用全局函数(::operator delete[](void *)) delete[] pArray;   在使用Array new申请动态内存时，释放内存时也应该用Array delete。\n如果不用Array delete, 析构函数只会被调用一次。\noperator new and operator delete  既可以重载全局operator new or delete, 也可以在类内部定义。 一般不选择重载全局的，由于全局的有可能在标准库的其他地方被使用。 operator new or delete 的实质就是调用了对应的malloc和free。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 重载成员operator new or delete class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;call ctor\u0026#34; \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;call dtor\u0026#34; \u0026lt;\u0026lt; endl; } void * operator new(size_t size) { cout \u0026lt;\u0026lt; \u0026#34;A::operator new()\u0026#34; \u0026lt;\u0026lt; endl; return ::operator new(size); } void * operator new[](size_t size) { cout \u0026lt;\u0026lt; \u0026#34;A::operator new[]()\u0026#34; \u0026lt;\u0026lt; endl; return ::operator new[](size); } void operator delete(void * p) { cout \u0026lt;\u0026lt; \u0026#34;A::operator delete()\u0026#34; \u0026lt;\u0026lt; endl; ::operator delete(p); } void operator delete[](void *p) { cout \u0026lt;\u0026lt; \u0026#34;A::operator delete[]()\u0026#34; \u0026lt;\u0026lt; endl; ::operator delete[](p); } };   各种类型比较大小 linux/centos 64位机器上如何编译32位程序  g++ -m32 test.cpp error: 找不到gnu/stubs-32.h文件的解决办法  1 2  yum install glibc-devel.i686 yum install libstdc++-devel.i686   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void display_data_size() { cout \u0026lt;\u0026lt; \u0026#34;指针大小: \u0026#34; \u0026lt;\u0026lt; sizeof(char *) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;字符数据: \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(char):\\t\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(unsigned char):\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(unsigned char) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;整型数据: \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(short):\\t\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(short) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(unsigned short):\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(unsigned short) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(int):\\t\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(unsigned int):\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(unsigned int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(long):\\t\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(long) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(unsigned long):\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(unsigned long) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(long long):\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(long long) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(unsigned long long):\\t\u0026#34; \u0026lt;\u0026lt; sizeof(unsigned long long) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;浮点型数据: \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(float):\\t\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(float) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(double):\\t\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(double) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;sizeof(long double):\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(long double) \u0026lt;\u0026lt; endl; }   // 32位 指针大小: 4 字符数据: sizeof(char):\t1 sizeof(unsigned char):\t1 整型数据: sizeof(short):\t2 sizeof(unsigned short):\t2 sizeof(int):\t4 sizeof(unsigned int):\t4 sizeof(long):\t4 sizeof(unsigned long):\t4 sizeof(long long):\t8 sizeof(unsigned long long):\t8 浮点型数据: sizeof(float):\t4 sizeof(double):\t8 sizeof(long double):\t12 // 64位 指针大小: 8 字符数据: sizeof(char):\t1 sizeof(unsigned char):\t1 整型数据: sizeof(short):\t2 sizeof(unsigned short):\t2 sizeof(int):\t4 sizeof(unsigned int):\t4 sizeof(long):\t8 sizeof(unsigned long):\t8 sizeof(long long):\t8 sizeof(unsigned long long):\t8 浮点型数据: sizeof(float):\t4 sizeof(double):\t8 sizeof(long double):\t16 ","description":"一些零碎知识点小结","id":11,"section":"posts","tags":["cplusplus"],"title":"c++基础小结","uri":"http://blog.nstop.cn/posts/cpp/cpp-notes/"},{"content":"壁纸搜集器 1、原理：使用bat文件获取指定路径下的文件，并将其后缀名改为.jpg 2、如何使用 a. 创建一个文件夹（任意位置）\nb. 在这个文件夹中新建记事本，粘贴以下内容，另存为ANSI格式，最后修改后缀名为bat\n1 2 3 4 5 6 7 8 9  set y=%date:~0,4%%date:~5,2%%date:~8,2% md .\\壁纸\\%y% del \u0026#34;.\\壁纸\\%y%\\*.jpg\u0026#34; set str1=\u0026#34;C:\\Users\\ set str2=\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\\LocalState\\Assets\\*\u0026#34; set picPath=%str1%%USERNAME%%str2% xcopy /d %picPath% .\\壁纸\\%y%\\ ren .\\壁纸\\%y%\\* *.jpg for /r %%F in (*.jpg) do if %%~zF LSS 300000 del \u0026#34;%%F\u0026#34;   c. 双击bat，你就能获得你想要的锁屏壁纸了\n3、注意事项 a. 粘贴内容时，每条cmd命令之间用回车符Enter换行。\nb. 每条cmd命令中不要存在不必要的空格和换行符。\nc. 记事本格式要是ANSI格式的，切记不能换成utf8，由于命令中出现了\u0026quot;壁纸\u0026ldquo;中文会导致乱码。\n","description":"一个小工具，用来收集windows上更新的壁纸","id":12,"section":"posts","tags":["tools"],"title":"壁纸搜集器","uri":"http://blog.nstop.cn/posts/other/%E5%A3%81%E7%BA%B8%E6%90%9C%E9%9B%86%E5%99%A8/"},{"content":"前言 有时候我们想要DIY属于自己的键位，但又不知道从何下手，本文将以win10为例，通过添加映射文件来达到修改键位的目的。如果你的系统是Mac OS，可以用软件karabiner-elements来更改。\n开始   打开注册表：win + R打开cmd， 输入regedit 回车。\n  搜索路径：计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Keyboard Layout,\n右键单击Keyboard Layout新建二进制文件Scancode Map\n  双击打开Scancode Map，如何编辑此文件呢?\n先了解具体的映射格式：\n每个键位都有对应的扫描码，扫描码为两个十六进制数：\n如左Ctrl键的扫描码为：00 1D，Esc键的扫描码为：00 01，\nCaps lock键的扫描码为：00 3A，左Alt键的扫描码为：00 38\n注意：在映射的时候，需要将每个键位对应的扫描码两个十六进制数互换。\n举例：\n(1). 将Esc键改为Caps lock键：01 00 3A 00\n(2). 将左Ctrl键改为左Alt键：1D 00 38 00\n下图中修改的键位就是将Esc和Caps lock互换，左Ctrl和左Alt互换。\n  重启电脑。\n  附上键位扫描码目录：\n  map code  Backspace 00 0E Caps Lock 00 3A Delete E0 53 End E0 4F Enter 00 1C Escape 00 01 HOME E0 47 Insert E0 52 Left Alt 00 38 Left Ctrl 00 1D Left Shift 00 2A Left Windows E0 5B Num Lock 00 45 Page Down E0 51 Page Up E0 49 Power E0 5E PrtSc E0 37 Right Alt E0 38 Right Ctrl E0 1D Right Shift 00 36 Right Windows E0 5C Scroll Lock 00 46 Sleep E0 5F Space 00 39 Tab 00 0F Wake E0 63 0 00 52 1 00 4F 2 00 50 3 00 51 4 00 4B 5 00 4C 6 00 4D 7 00 47 8 00 48 9 00 49 - 00 4A /* 00 37 . 00 53 / 00 35 /+ 00 4E Enter E0 1C F1 00 3B F2 00 3C F3 00 3D F4 00 3E F5 00 3F F6 00 40 F7 00 41 F8 00 42 F9 00 43 F10 00 44 F11 00 57 F12 00 58 F13 00 64 F14 00 65 F15 00 66 Down E0 50 Left E0 4B Right E0 4D Up E0 48 Calculator E0 21 E-Mail E0 6C Media Select E0 6D Messenger E0 11 My Computer E0 6B ’ ” 00 28 - _ 00 0C , \u0026lt; 00 33 . \u0026gt; 00 34 / ? 00 35 ; : 00 27 [ { 00 1A \\ | 00 2B ] } 00 1B ` ~ 00 29 = + 00 0D 0 ) 00 0B 1 ! 00 02 2 @ 00 03 3 # 00 04 4 $ 00 05 5 % 00 06 6 ^ 00 07 7 \u0026amp; 00 08 8 * 00 09 9 ( 00 0A A 00 1E B 00 30 C 00 2E D 00 20 E 00 12 F 00 21 G 00 22 H 00 23 I 00 17 J 00 24 K 00 25 L 00 26 M 00 32 N 00 31 O 00 18 P 00 19 Q 00 10 R 00 13 S 00 1F T 00 14 U 00 16 V 00 2F W 00 11 X 00 2D Y 00 15 Z 00 2C Close E0 40 Fwd E0 42 Help E0 3B New E0 3E Office Home E0 3C Open E0 3F Print E0 58 Redo E0 07 Reply E0 41 Save E0 57 Send E0 43 Spell E0 23 Task Pane E0 3D Undo E0 08 Mute E0 20 Next Track E0 19 Play/Pause E0 22 Prev Track E0 10 Stop E0 24 Volume Down E0 2E Volume Up E0 30 ? - 00 7D E0 45 Next to Enter E0 2B Next to L-Shift E0 56 Next to R-Shift E0 73 DBE_KATAKANA E0 70 DBE_SBCSCHAR E0 77 CONVERT E0 79 NONCONVERT E0 7B Internet E0 01 iTouch E0 13 Shopping E0 04 Webcam E0 12 Back E0 6A Favorites E0 66 Forward E0 69 HOME E0 32 Refresh E0 67 Search E0 65 Stop E0 68 My Pictures E0 64 My Music E0 3C Mute E0 20 Play/Pause E0 22 Stop E0 24 + (Volume up) E0 30 - (Volume down) E0 2E Media E0 6D Mail E0 6C Web/Home E0 32 Messenger E0 05 Calculator E0 21 Log Off E0 16 Sleep E0 5F Help(on F1 key) E0 3B Undo(on F2 key) E0 08 Redo(on F3 key) E0 07 Fwd (on F8 key) E0 42 Send(on F9 key) E0 43   \n  ","description":"修改键位小技巧","id":13,"section":"posts","tags":["tools"],"title":"windows改键位","uri":"http://blog.nstop.cn/posts/other/keyboard_mapping/"},{"content":" 一但使用零数组，基本上就不能跨平台了。零数组是gnu c上特有的。  1 2 3 4 5 6 7 8 9 10 11 12 13  // 平常我们定义数组的时候，给出的长度基本上都大于零的 // 在gnuc平台上竟然还可以这么写 int array[0]; // 并不报错  // 更奇怪的是 printf(\u0026#34;array\u0026#39;s size: %d\\n\u0026#34;, sizeof(array)); // result: array\u0026#39;s size: 0  // 更有甚者 array[1] = 2; array[2] = 3; printf(\u0026#34;%d, %d\\n\u0026#34;, *(array + 1), *(array + 2)); // result: 2, 3  // 什么鬼？违背常理啊    我们可以利用这个来干嘛呢  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 创造一个不定长数组。 struct buf { int len; char p[0]; // 为什么不直接用char *p？char *占一个指针的大小，而p[0]不占大小 \t// 另外char *p 需要再去开辟内存空间或者是指向已分配好的内存空间， \t// 但是，这样就不便于内存的释放管理了。 }; int length = 100; struct buf * pBuff = (struct buf *)malloc(sizeof(struct buf) + length); strcpy(pBuff, \u0026#34;hello world!\\n\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, pBuff-\u0026gt;p); free(buf); // 释放内存就是怎么简单  // 那为什么不直接用char *p = (char *)malloc(sizeof(char) * length); 呢？ // 释放内存时不照样可以用 free(buf); 干净释放  // 这样就不能时时刻刻随便获得数组的长度了。 // 假设这个指针p在其他作用域范围使用，怎么在当前作用域中获得它的长度呢？ // 所以就需要用一个len来时刻保存其长度，也就回到了前面的结构体身上了。   ","description":"gnuc下的一些特性","id":14,"section":"posts","tags":["c"],"title":"零数组","uri":"http://blog.nstop.cn/posts/c/%E9%9B%B6%E6%95%B0%E7%BB%84/"},{"content":"Mac下 绕过国内DNS解析，直接访问github的CDN节点，加速访问的方法   打开IPAddress.com网站，查询下面3个网址对应的IP地址\n github.com github.github.io github.global.ssl.fastly.net    sudo vim /etc/hosts\n将搜寻到的ip一一对应写入文件保存即可\n格式如：140.82.114.3 github.com\n  刷新DNS缓存 连续输入以下三条命令\n sudo killall -HUP mDNSResponder sudo killall mDNSResponderHelper sudo dscacheutil -flushcache    ","description":"github国内访问速度过慢，可以修改hosts来加快速度","id":15,"section":"posts","tags":["github"],"title":"加速github访问","uri":"http://blog.nstop.cn/posts/other/%E5%8A%A0%E9%80%9Fgithub%E8%AE%BF%E9%97%AE/"},{"content":"前言 YouCompleteMe是一款支持代码自动补全功能的vim插件，我们使用vim编辑器时，可能会用到大量的vim插件，但是如果一个个去手动安装的话，不便于管理。但有了插件管理器，一切都变得简单化。它通过一个配置文件能够很方便的管理大量的插件，现在流行的插件管理器有vundle、vim-plug等等，这里我采用比较新的vim-plug来安装YouCompleteMe。\n1. 在装之前必须要学会灵活使用GitHub，不管是vim还是vim插件基本上都来自GitHub，可以说在GitHub上无所不有。 2. 安装vim插件管理器vim-plug，在安装之前你可以先去GitHub上搜一下，看看其发布者他的安装帮助文档（其实这上面写的很详细的，只不过是英文而已，对我们中国人不太友好）。 这里我以CentOS为例，在终端输入：\n1 2  curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim   可能会报以下错误：\nFailed to connect to raw.githubusercontent.com port 443: Connection refused\n没事，我们修改一下配置文件/etc/hosts,为raw.githubusercontent.com添加域名解析就行了。\n  打开hosts：sudo vim /etc/hosts\n  在文件最后添加内容：199.232.28.133 raw.githubusercontent.com\n  重新执行命令：\n1 2  curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim     3. 装完vim-plug之后，我们就可以利用其来完成YouCompleteMe的安装了，直接在~/.vimrc配置文件头部加入以下代码 1 2 3 4 5 6  call plug#begin( \u0026#39;~/.vim/plugged\u0026#39;) \u0026#34; 这个就是装插件的写法格式，Plug 后面加\u0026#39;GitHub用户名/插件名\u0026#39; Plug \u0026#39;ycm-core/YouCompleteMe\u0026#39; call plug#end()   wq保存退出，再打开该文件直接键入:PlugInstall进行安装，会显示其下载进度。（下载YCM的过程相当缓慢，请耐心等待，你完全可以去看一部电影先）\n。。。\n下载完后用以下命令核查一下你的下载文件是否完全\n1  git submodule update --init --recursive   如果你在之前的下载不完全，那么你可能又要等上一段时间了。\n4.你如果看了GitHub上的YouCompleteMe插件的帮助文档，那么就会知道它不再支持Python2版本了，所以如果你的机器上还没有Python3版本，那么按照以下方法进行安装  安装Python3环境依赖包  1 2 3  yum -y groupinstall \u0026#34;Development tools\u0026#34; yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel yum install libffi-devel python-devel python3-devel -y    下载python3安装包  1 2  # cd /tmp # wget https://www.python.org/ftp/python/3.8.2/Python-3.8.2.tgz    解压并编译安装  1 2 3 4 5 6 7  # tar xvf Python-3.8.2.tgz # cd Python-3.8.2 # ./configure --enable-shared --prefix=/usr/local/python3 # make \u0026amp;\u0026amp; make install # 拷贝动态库到/usr/lib64,保证能够被正常调用到 # cp /usr/local/python3/lib/libpython3.8.so.1.0 /usr/lib64    配置环境变量  打开配置文件\n1  vim /etc/profile   在最后添加以下内容：\n1 2  PATH=/usr/local/python3/bin:$PATH export PATH   使配置文件生效\n1  source /etc/profile   5. 接下来更新vim 如果你的vim版本低于7.3.1578版本，那么你就有必要更新一下了。\n更新vim步骤如下：\n 下载最新vim版本  1  git clone https://github.com/vim/vim.git    编译安装  1 2 3 4 5 6 7 8 9 10 11  cd vim/src ./configure --with-features=huge \\ --enable-pythoninterp=yes \\ --enable-python3interp=yes \\ --enable-multibyte \\ --with-python-config-dir=/usr/lib64/python2.7/config \\ --with-python3-config-dir=/usr/local/python3/lib/python3.8/config-3.8-x86_64-linux-gnu/ \\ --prefix=/usr/local/vim8 sudo make \u0026amp;\u0026amp; make install    配置环境变量  1 2 3 4 5 6 7 8  vim /etc/profile # 在末尾添加以下内容 PATH=/usr/local/vim8/bin:$PATH export PATH # 使配置文件生效 source /etc/profile    核查一下vim版本，如果没有更新，切换下用户（当前普通用户=\u0026gt;root=\u0026gt;当前普通用户）  1  vim --version    核查vim是否支持python3  1  vim --version | grep python   6. 正式进入Ycm安装主题  安装必要的插件(cmake)  1  yum install cmake clang    进入YCM的根目录  1  cd ~/.vim/plugged/YouCompleteMe    执行命令（这里我只是安装了支持c-family的自动提示功能，具体要安装其他语言的可以看官方文档）  1  python3 ./install.py --clang-completer   接下来只需要等待。。。\n 安装完成之后，用vim打开一个文件（你会发现报错）  错误提示如下\n1  /lib64/libstdc++.so.6: version `GLIBCXX_3.4.20\u0026#39; not found (required by /home/zdy/.vim/plugged/YouCompleteMe/third_party/ycmd/third_party/clang/lib/libclang.so.10)    检测当前动态库情况  1  strings /usr/lib64/libstdc++.so.6 | grep GLIBC   你会发现并没有GLIBCXX_3.4.20\n那么就升级libstdc++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 查看提供的版本 yum provides libstdc++.so.6 # 显示结果如下 Loaded plugins: auto-update-debuginfo, fastestmirror Loading mirror speeds from cached hostfile * base: mirrors.cn99.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com libstdc++-4.8.5-39.el7.i686 : GNU Standard C++ Library Repo : base Matched from: Provides : libstdc++.so.6 # 根据提供的版本信息进行安装 yum install libstdc++-4.8.5-39.el7.i686    下载libstdc++.so.6.0.26  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  ls -l /usr/lib64 | grep libstdc++ # 显示结果 lrwxrwxrwx. 1 root root 30 Jul 14 14:35 libstdc++.so.6 -\u0026gt;/usr/lib64/libstdc++.so.6.0.19 -rwxr-xr-x. 1 root root 991616 Aug 7 2019 libstdc++.so.6.0.19 # 把libstdc++.so.6.0.26文件放到/usr/lib64下 # 删除软链接libstdc++.so.6 rm /usr/lib64/libstdc++.so.6 # 为libstdc++.so.6.0.26创建新的链接 ln -s /usr/lib64/libstdc++.so.6.0.26 /usr/lib64/libstdc++.so.6 # 再次查看动态库信息 strings /usr/lib64/libstdc++.so.6 | grep GLIBC    打开vim应该没问题了，但是需要配置一下ycm的配置文件  1 2 3 4 5 6 7 8 9  vim ~/.vimrc # 添加内容 let g:ycm_global_ycm_extra_conf = \u0026#39;~/.vim/plugged/YouCompleteMe/third_party/ycmd/example/.ycm_extra_conf.py\u0026#39; # 配置c与cpp文件的代码补全触发器, 单独输入一个字母就会触发 let g:ycm_semantic_triggers = { \\  \u0026#39;c\u0026#39;: [\u0026#39;-\u0026gt;\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;re![a-zA-Z]\u0026#39;], \\  \u0026#39;cpp\u0026#39;: [\u0026#39;-\u0026gt;\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;::\u0026#39;, \u0026#39;re![a-zA-Z]\u0026#39;], \\ }   7. .ycm_extra_conf.py这个配置文件可以根据自己的需求来进行更改 以c/c++为例， 加载/usr/include和/usr/include/c++/4.8.5/\n# 找到此处,在其后添加路径 flags = [ '-Wall', '-Wextra', '-Werror', '-Wno-long-long', '-fexceptions', '-DNDEBUG', '-x', 'c++', '-isystem', '/usr/include', '-isystem', '/usr/include/c++/4.8.5' ] ","description":"简明介绍怎样正确安装vim下的自动补全插件YCM","id":16,"section":"posts","tags":["vim"],"title":"Centos7下用vim-plug安装YouCompleteMe","uri":"http://blog.nstop.cn/posts/vim/centos7%E4%B8%8B%E7%94%A8vim-plug%E5%AE%89%E8%A3%85youcompleteme/"},{"content":"前言 学习Linux的笔记总结，主要是对当天学到的知识进行整理，以便将来能用到能够快速回忆。\n1、终端命令快捷键 以下命令主要是方便在终端输入命令时的操作\n清屏：clear 或 ctrl + l\n查看最近使用命令的历史纪录：history\n建议使用ctrl + xxx 代替 上下左右箭头 操作\n 向前翻阅一个历史命令：ctrl + p 或 上箭头\n向后翻阅一个历史命令：ctrl + n 或 下箭头\n  向左移动光标： ctrl + b 或 左箭头\n向右移动光标： ctrl + f 或 右箭头\n  移动到行首： ctrl + a\n移动到行尾： ctrl + e\n  删除光标所在处字符：ctrl + d\n删除光标前一个字符：ctrl + h\n删除光标所在处到末尾的所有字符：ctrl + k\n删除光标前面的所有字符：ctrl + u\n 像以上这些快捷键还有很多，这里只是总结一些常用的。\n2、Linux系统目录结构 一些比较常用的目录的作用\n /bin : 这里存放的是我们经常用到的一些shell命令，如cat、ls、cp、rm、mv等等。\n/root ：超级管理员（root）的家目录\n/usr ：用户软件资源目录，存放的是用户的一些应用程序文件\n/opt ：一般用来存放第三方的软件安装包。\n/home ：存放所有普通用户的家目录，如普通用户为jake，那么其家目录为/home/jake\n/sbin : 存放的是系统管理员使用的系统管理程序\n/etc : 存放一些系统或应用程序的配置文件\n/dev : 存放的是一些外设（如u盘、光驱、磁盘）的设备文件\n/media : 和/mnt 一样存放的是外设文件，但是这是系统自动识别外设并挂载的设备文件。\n/mnt : 存放手动挂载的文件系统，如可以将u盘或者光驱手动挂载在该目录下\n/boot ：存放的是Linux启动时所需要的系统核心文件，包括一些链接文件以及镜像文件，不要轻易修改或删除这里面的文件\n/tmp : 存放的是一些临时文件\n/var : 经常要进行修改变动的文件可以放到该目录下。如各种日志文件\n/lib : 存放的是系统最基本的动态链接库（共享库），类似windows系统下的DLL文件。\n 3、Linux常用命令  操作目录或文件   显示目录详细信息   显示当前目录下的子目录或者文件：ls 或者 tree\ntree命令需要安装，tree 会将当前目录下所有文件以树的形式进行展示\n 显示所有（包括隐藏文件）：ls -a\n显示详细信息：ls -l\n   创建   创建目录：mkdir 目录名 例如：mkdir aa: 创建一个aa目录\n创建多层目录：mkdir 目录1/目录2/目录3 -p 例如：mkdir aa/bb/cc -p\n创建文件：touch 文件名\n 例如：touch aa，如果文件名aa不存在，则创建文件aa\n如果文件名存在，则将修改文件的时间，但是不会更改文件内容\n如果跟某目录名重名，会修改已存在目录的时间，并不会创建文件\n   删除   删除空目录: rm 目录名\n删除非空目录: rm -r 目录名\n删除非空目录带提示: rm -ri 目录名\n删除文件: rm 文件名\n删除文件带提示: rm 文件名\n删除文件或目录不带提示：rm 文件或目录\n  复制   cp 文件1 文件2 : 如 cp aa bb\n bb不存在时, 会创建一个名为bb的文件并且将文件aa的内容复制\nbb存在时, bb文件的内容会被清除并且将文件aa的内容复制过来\n cp 目录1 目录2 -r : 如 cp cc dd -r\n 如果目录dd存在时,会将目录cc 复制到 目录dd 下,也就是说dd下会存在一个目录cc\n如果目录dd不存在时,会创建一个dd目录,并且将aa目录下的所有内容拷贝到dd目录下\n   移动   mv 文件1 文件2 : 如 mv a1 a2\n 如果文件a2不存在时, 则相当于把文件a1改名为文件a2\n如果文件a2存在时, 会将文件a1删除,并且a1的内容会覆盖到文件a2中去\n   mv 目录1 目录2: 如mv aa bb\n 如果目录bb不存在时, 则相当于把目录aa改名为目录bb\n如果目录bb存在时, 会将目录aa 移动到 目录bb下(注意: 如果目录bb下原本存在目录aa,则会报错)\n   查看文件\n这里主要区分三种查看方式cat more less   cat 文件名 : 主要打开内容比较少的文件,内容多的文件显示不完整\nmore 文件名 : 查看内容时不能往前翻, 按space换页,按Enter换行\nless 文件名 : 在more的基础上增加了能往回看的功能\n补充两个\nhead 文件名\ntail 文件名\n  查看文件属性的命令   查看文件属性：wc - [c|w|l|m] 文件名\nl：行数；c：字节数；m：字符数；w：单词数\n应用：查看当前目录下有多少个文件和子目录：ls | wc -l\n查看二进制文件：od -t [c/d/f/u/o/x] 二进制文件名\n c ：以ASCII码显示 ；d：十进制数；f：浮点数；u：无符号十进制数；o：八进制数；x：十六进制数\n 查看目录大小：du -h\n查看磁盘使用率：df -h\n 软硬链接的创建   为文件创建软链接：ln -s 文件的绝对路径 软链接名   软链接名一般以soft为后缀\n如：ln -s /home/jake/aa /home/jake/bin/aa.soft\n  为文件创建硬链接：ln 文件的绝对路径 硬链接名   硬链接名一般以hard为后缀\n如：ln /home/jake/aa /home/jake/bin/aa.hard\n 其他常用命令   显示当前用户: whoami 借用root权限: sudo 查看shell命令在哪个路径下: which 命令 如: which cp 切换到当前用户家目录: 如当前用户为jake   cd\ncd ~\ncd /home/jake\n  切换到前一个路径 cd -(这个命令可以在相邻的两个路径来回切换)  4、Linux文件权限 先说明一下\n[root@localhost ~]#\nroot表示当前用户\nlocalhost表示主机名\n~ 表示当前所在目录（此时是root的家目录）\n# 表示的是超级管理员;如果是$表示普通用户\n修改文件目录权限\nchmod [u|g|o|a][+|-|=][r|w|x] 文件或目录名\n u ：所有者 ，g ：所属组 ，o ：其他人 ，a ：all的简写，三者都改\n+ ：增加权限，- ： 减少权限，= ：重新赋予权限\nr ：读 ，w ：写，x ：执行\n 如：\nchmod a+x aa 将aa的所有者、所属组、其他人都增加执行权限\nchmod ug=rw aa 将aa的所有者、所属组都更改为可读可写权限\nchmod [+|-|=] 三位数 文件名\n + : 增加权限， - ： 减少权限， = ： 重新赋予权限 ，一般可省略\n三位数每一位分别代表所有者、所属组、其他人\n读的权值为4，写的权值为2，执行的权值为1\n如：\nchmod 664 aa 等同于chmod =664 aa aa的所有者、所属组具有可读可写权限，其他人只具有读权限\nchmod -112 aa aa的所有者、所属组取消可执行权限，其他人取消写权限\n 更改文件或目录的所有者和所属组\nsudo chown 所有者:所属组 -R 文件或目录名\n更改文件或目录的所属组\nsudo chgrp 所属组 文件或目录名\n温馨提示：目录必须具有执行权限才可进入\n5、Linux文件或目录颜色区分  白色：普通文件\n蓝色：目录\n青色：链接\n黄色：设备文件\n绿色：可执行文件\n红色：压缩文件\n灰色：其他\n 6、Linux文件检索和内容查找  文件查找 find   按文件名查找: find 查找路径 -name \u0026quot;文件名\u0026quot; 按文件类型查找: find 查找路径 -type 文件类型参数[f/d/b/c/l/s/p]   文件类型参数 f 代表普通文件，其他类型参数的都是前面提过的\n  按文件大小查找: find 查找路径 -size +/- [k/M/G]   + : 大于， - ： 小于 ；\nk、M、G都是文件大小单位(k是小写的)\n如：find ./ -size +5k -size -1M 在当前路径下查找大于5k小于1M的文件\n 文件内容 grep\ngrep -r \u0026quot;文件内容\u0026quot; 搜索目录\n如： grep -r \u0026quot;abjsl\u0026quot; ./ 在当前路径下递归查找有没有存在内容中有“abjsl”的文件  7、u盘的手动挂载与卸载 自动挂载 ： 一般在/media/下\n手动挂载 ： 一般指定在/mnt/ 下\n  umount卸载: umount 要卸载的设备（其实就是一个目录，linux一切皆文件）\n  查看设备信息（查找要挂载的设备的路径）：\nsudo fdisk -l\n  mount 挂载：mount 挂载设备路径 /mnt\n   注意：这里手动挂载一般选择在/mnt下，当然也可以挂载到其他目录，但是要保证其他目录内的内容和设备中的内容没有重名的，不然设备中的文件会覆盖原来目录的文件，这里的覆盖并不是说原来目录的文件就被删除了，只是说暂时不存在而已当你卸载设备后，原来目录的文件又会还原\n所以在不能确定的情况下最好保证要手动挂载的指定目录是一个空目录（建议/mnt）\n 8、压缩与解压缩   gzip gunzip\n  gzip *.txt (不会保留源文件，并且会一一压缩每个txt文件，注意：这里不会合并为一个文件)\n  gunzip *.gz (不会保留源文件，并且会一一解压每个gz文件)\n    bzip2 bunzip2 \u0026ndash;需要安装\n  bzip2 *.txt (不会保留源文件，并且会一一压缩每个txt文件,跟gzip *.txt 一样的效果)\n  bzip2 -k * .txt（会保留源文件，并且会一一压缩每个txt文件\n  bunzip2 *.bz2 (不会保留源文件，并且会一一解压每个bz2文件)\n     注意事项：gzip 和 bzip2 不能压缩目录\n   tar\n  -参数\nc : 压缩\nv : 显示提示信息 \u0026ndash; 可以省略\nf : 指定压缩文件的名字\nx : 解压\nj : \u0026ndash; 使用bzip2的方式压缩文件 \u0026ndash; .bz2\nz ：\u0026ndash; 使用gzip的方式压缩文件 \u0026ndash; .gz\n  压缩：\ntar -zcvf 生成的压缩名(xxx.tar.gz) 要压缩的文件或目录\ntar -jcvf 生成的压缩名(xxx.tar.bz2) 要压缩的文件或目录\n  在当前目录下解压：tar -jxvf 压缩包\n  解压到指定目录下：tar -zxvf 压缩包 -C 指定解压的目录\n    rar \u0026ndash;需要安装\n  压缩：rar a 生成的压缩包名字 要压缩的文件\n  解压：rar x 压缩包 指定解压到哪个目录\n    zip unzip \u0026ndash;需要安装 \u0026ndash;可压缩目录\n  zip 生成的压缩包名字 要压缩的文件\n  zip -r 生成的压缩包名字 要压缩的目录\n  unzip 压缩包名字 -d 指定解压到哪个目录\n    9、常用网络与查看进程相关命令   查看进程\n  查看所有进程：ps a\n  能查看到进程正在被使用的所属用户： ps au\n  查看包括没有终端的所有进程： ps aux\n  使用管道 | ，格式 ： 指令1 | 指令2 （指令1的输出作为指令2的输入，最后结果为指令2的输出）\n例如： 查看所有内容中有bash的进程： ps aux | grep bash\n   注意在使用 ps aux | grep bash这条命令时，它也是一个进程\n   终止进程： kill -9 进程pid\n9代表信号SIGKILL\n可以通过 kill -l 命令查看所有信号\n  查看当前进程的环境变量 : env\n例子：查看当前进程环境变量中有PATH的\nenv | grep PATH\n   linux下的环境变量的格式 key-value\nkey=value:value:value:value(当有多个环境变量时，用 : 分隔)\n   top : 类似windows中的任务管理器(只读，不能操作)\n  ifconfig 查看ip相关信息\nping www.baidu.com\nnslookup www.baidu.com 查看服务器域名对应的ip地址\n  10、用户管理  添加用户 ： adduser 用户名 为用户设置密码： passwd 用户名 然后输入两次密码 另一种方式设置密码：echo \u0026quot;passwd\u0026quot; | passwd --stdin username 删除用户： userdel -r 用户名  11、常用服务器搭建与配置 ftp服务器搭建   作用：文件的上传和下载 （不能是目录，要传目录的话直接可以将其打包）\n  服务器端：\n安装 ：sudo yum install vsftpd\n修改配置文件：/etc/vsftpd.conf\n重启服务器： sudo service vsftpd restart\n  客户端：\n安装ftp：yum install ftp\n实名用户登录: （可以随意地切换目录，对于服务器来说不安全）\nftp serverip ===\u0026gt; 输入用户名和密码\nput filename 上传文件\nget filename 下载文件\n匿名用户登录：（只能在服务器指定的目录下操作，服务器须在配置文件中添加指定匿名用户访问的目录，或者用默认的目录 /srv/ftp）\nftp serverip ===\u0026gt; 用户名：anonymous 密码：不需要写\n退出： exit 或者 quit 或者 bye\n  lftp ：针对ftp客户端的软件（这个可以上传目录，还可以一次性上传多个文件）\n实名登录：lftp username@serverip ===\u0026gt; 输入密码\n匿名登录：lftp serverip ===\u0026gt; 输入login\n操作：\n上传单个文件：put fileName\n上传多个文件：mput fileName1 fileName2\n下载单个文件：get fileName\n下载多个文件：mget fileName1 fileName2\n下载整个目录以及子目录：mirror dirName\n上传整个目录以及子目录：mirror -R dirName\n  nfs服务器搭建   作用：开发项目组中共享文件夹\n  服务器：\n安装： sudo yum install nfs-kernel-server\n创建一个欲共享出去的目录：mkdir -p /home/jerry/share\n打开配置文件： sudo vi /etc/exports\n添加共享目录的绝对路径 ：/home/jerry/share *(rw,sync) rw 可读可写 ro 只读\n重启服务：sudo service nfs-kernel-server restart\n  客服端：\n通过挂载该目录来获取共享目录中的资源\nmount serverIp:共享目录绝对路径 挂载目录位置\n如：mount serverIp:/home/jerry/share /mnt\n  ssh服务器搭建  ssh服务器\n====\u0026gt;安装ssh: sudo yum install openssh-server\n====\u0026gt;查看是否安装 sudo aptitude show openssh-server 客户端：\n====\u0026gt;远程登录：ssh serverip@username ===\u0026gt; 密码\n====\u0026gt;退出： logout scp命令 (super copy)\nscp -r 目标用户名@目标主机ip:目标文件的绝对路径 保存到主机的相对/绝对路径   拷贝目录需要加参数（-r）\n 12、查看man帮助文档 使用man man查看\n安装c库函数帮助文档 CentOS系统可能没有自带c库函数 \u0026ndash;需要自己安装\n安装：yum install man-pages.noarch\n安装中文版man  获取安装包  1  # wget https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/manpages-zh-1.5.2.tar.bz2/cab232c7bb49b214c2f7ee44f7f35900/manpages-zh-1.5.2.tar.bz2   解压安装包到当前目录并进入解压包  1 2  # tar jxvf manpages-zh-1.5.2.tar.bz2 # cd manpages-zh-1.5.2   安装(使用者最好是root，由于权限问题)  1 2  # ./configure --disable-zhwt # make \u0026amp;\u0026amp; make install   修改配置文件\n为了不覆盖man命令，我们用cman命令来查看中文版的帮助文档，在.bash_profile中追加以下内容(这个文件在用户的家目录中)\n打开.bash_profile文件  1  # vi /home/你自己的用户名/.bash_profile   追加内容：alias cman='man -M /usr/local/share/man/zh_CN'\n更新.bash_profile文件：\n1  # source /home/你自己的用户名/.bash_profile   拓展\n第4步也可以在用户家目录下的.bashrc文件中追加alias cman='man -M /usr/local/share/man/zh_CN'，然后再更新.bashrc文件   ~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.\n~/.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.\n 13、vim 编辑器的使用 三种模式  命令模式：可以在此模式下进行光标移动，以及删除、复制操作等操作，低行模式和插入模式的中间层 插入模式：在此模式下可以向文本添加信息文字 低行模式：在此模式可以保存、退出文本，查找、替换字符以及显示行号等操作  命令模式下的操作 移动    前 下 上 后 行首 行尾     h j k l 0 $     移动到文件开始位置：g+g\n移动到文件末尾： G\n跳转到第9行：9 + G\n 删除  删除单个字符：  删除光标位置的字符：x 删除光标前的字符：X   删除多个字符：  删除单词：光标移动到某个单词的首个字符：按d + w 删除光标之前所有的字符：d + 0 删除光标之前所有的字符：d + $或者 D 删除光标所在行： d + d 删除光标所在行之后n - 1行(包括光标所在行)： 行号(n) + d + d    复制  跟删除差不多的操作 复制光标所在的前n个单词：nyb 复制光标所在的后n个单词：nyw 复制光标之前所有的字符：y + 0 复制光标之前所有的字符：y + $ 复制光标所在行：y + y 复制光标所在行之后n - 1行(包括光标所在行)： 行号(n) + y + y  粘贴  在光标所在行的下一行粘贴内容：p 在光标所在行的上一行粘贴内容：Shift+p  剪切  删除 == 剪切 （前面的删除操作其实真正意义上就是剪切）  撤销操作  按键：u 回撤销：Ctrl+r  通过可视模式选中内容  当你想要选中文本中任意一段内容进行操作：\n1.移动光标到指定内容开头，然后按v进入可视模式，\n2.再用hjkl方向键移动来选择要操作的内容\n3.操作按y即复制，按d即删除 注意：在可视模式复制的情况下粘贴和非可视模式复制的情况有所不同  按p 会在光标所在位置的后边粘贴内容 按P 会在光标所在位置的前边粘贴内容    查找  输入 / + 查找内容 从光标位置向下查找 输入 ? + 查找内容 从光标位置向上查找 向上向下切换按键：n依次向下 N依次向上 或者直接查找单词：  把光标放到要查找的单词上，然后按 # 就会选中所有跟这个其他相同的单词，可以通过n和N切换    替换  替换单个字符：移动光标到某个字符上，按 r + 要替换的内容  缩进  按键 \u0026gt;+\u0026gt; 和 \u0026lt;+\u0026lt;  在文件中查看某个系统函数的帮助文档  查看在当前文件中出现某些系统函数如printf可以通过以下操作 先[章号]+Shift+k 查看帮助文档(man文档)  命令行模式切换到插入模式    光标后插入 光标所在行尾插入     a A   光标前插入 光标所在行首插入   i I   光标所在行的下一行插入 光标所在行的上一行插入   o O   先删除光标位置的字符，再插入到光标位置 先删除光标所在行的内容，再插入到行首   s S    底行模式 a、在命令模式下切换到末行模式用:\nb、跳转到某行：直接输入行号\nc、如：替换某行的某段内容如替换光标所在行中的wo为women\n先将光标移动到指定行，再切换到末行模式\n按s/wo/women（这只替换这行中第一个wo，需要替换这行中所有的wo则要加上/g）\nd、如：替换指定所有行的指定内容如单词\n切换到末行模式 输入%s/wo/women/g\n如要指定20-24行中的wo替换为women：切换到末行模式 输入20,24s/wo/women/g\n 总结：% 表示全部 .表示当前行 $表示最末行\n e、在末行模式可以输入bash命令，格式：! + bash命令(如!pwd 或者 !ls -l等等)\nf、按两次Esc即可切换到命令模式\ng、保存 ： w 保存退出： wq或者zz或者x 退出不保存： q!\nh、在底行模式下也可以复制 ：\n :10,20y 表示复制第10行到20行的内容 :.,$-5y 表示复制当前行到倒数第五行的内容  分屏操作 首先必须在末行模式下：\n1、sp (当前文件进行分屏）分为上下两个屏\n2、vsp + 文件（指定文件进行分屏）分为左右两个屏\n3、使用Ctrl+w+w 两个屏中来回切换\n4、保存并退出所有文件： wqall\nvim自定义配置 vim可以通过修改.vimrc配置文件来改造成一款属于自己的IDE\n 修改系统级的vim配置文件（/etc/vimrc）：所有用户都会应用\n修改用户级的vim配置文件（用户的宿主目录下的.vimrc）: 只有当前用户应用\n 14、gcc编译原理  gcc 编译c文件会经过以下4个步骤：===\u0026gt; 以hello.c 生成hello可执行文件为例   预处理：gcc -E hell0.c -o hello.i 编译：gcc -S hello.i -o hello.s 汇编：gcc -c hello.s -o hello.o 链接：gcc hello.o -o hello   前面这4条命令可以合并成一条：gcc hello.c -o hello\n注意：虽然是一条命令，但编译器处理的时候仍然是按照4步处理的\n默认生成目标文件为a.out\n gcc编译器的一些常用参数 -E -S -c -o -g -I -O -Wall -D\n-O : 优化代码（优化级别为0 1 2 3，0表示不优化，数字越大级别越大）\n-D : DEBUG（加宏值）\n-Wall ：提示警告信息\n-g ：GDB调试时需要加的参数\n-I ：提供头文件的路径  15、静态库与动态库 静态库   命名规则：lib + 库名字 + .a\n  制作步骤：\n（1）需要的文件 ：二进制文件（.o）gcc -c *.c 将c文件生成二进制文件\n（2）ar rcs + 自定义静态库名字 + 所有的二进制文件(*.o) ==== 需要安装ar\n  静态库的使用：\n使用方需要 头文件（include目录）+ 静态库 （通常放在lib目录下）\n两种方法：\n1）直接指定静态库位置\n执行命令：gcc nihao.c -I include lib/libMyTest.a -o app\n2）用参数-L -l 指定静态库\n执行命令：gcc main.c -I include -L lib -l MyTest -o app\n  动态库   命名规则：lib + 库名字 + .so\n  制作步骤：\n1）c文件 ===\u0026gt; 二进制文件(.o) : gcc -fpic -c *.c\n2）gcc -shared -o + 动态库名字 + 所有的二进制文件(*.o) -I头文件路径\n  动态库的使用：\n两种使用方法：\n1）直接指定动态库位置：gcc main.c -I include lib/libMytest.so -o app\n2）用参数-L -l指定动态库\n用ldd + 可执行程序名称 可以查看当前程序需要的动态库的加载情况\ngcc main.c -I include -L lib -l MyTest -o app\n 这时候你会发现动态库链接失败\n 四种加载动态库的方法：\n1）把动态库放到/lib目录下（不推荐）\n2）export LDD_LIBRARY_PATH=动态库的绝对路径（临时的，重启终端后又会造成链接动态库失败）\n3）在当前用户家目录下的.bashrc文件中添加export LDD_LIBRARY_PATH=动态库的绝对路径（相对来说永久的，在每次终端启动的时候会执行.bashrc配置文件中的命令）\n4）这种方法最常用\n找到etc/ld.so.conf 配置文件在末尾加上 动态库绝对路径，更新配置文件 sudo ldconfig -v\n  静态库和动态库的优缺点   优点\n 静态库：1.发布程序时，不需要提供对应的静态库。2.加载库的速度快 动态库：1.应用程序体积小。2.当库更新时，应用程序不需要重新编译    缺点\n 静态库：1.库被打包到应用程序中，造成应用程序过于臃肿。2.当库更新时，应用程序需要重新编译 动态库：1.发布程序时需要提供库。2.加载库的速度相对较慢    16、 GDB调试 进入调试：gdb 执行程序名 ===\u0026gt; 前提：执行程序必须是加了调试信息的（-g）\n常用操作 list(l) # 查看载入文件的源代码 start # 开始启动，只会执行一步就会停下 run(r) # 程序开始执行， 直到遇到第一个断点才停下 next(n) # 单步执行 （不会进入所调用的子函数内部） step(s) # 单步执行 （会进入所调用的子函数内部） until # 运行到函数某一行 continue(c) # 执行到下一个断点或程序结束 set width + 数目 # 设置GDB的行宽 finish # 退出当前子函数体（注意循环体中必须没有断点） u # 退出当前子函数体 设置断点 break(b) + 文件名:行号(函数名) (不加文件名即为当前文件) info(i) b\t# 查看所有的断点信息 del(delete) 断点号\t# 删除断点 clear + 要清除的断点所在行号\t# 删除指定行的断点 break(b) + 行号 + if + 条件\t# 设置带条件的断点 如 b 10 if i==5 # 在循环语句中很实用 查看值 查看变量的值:\tp 变量名 查看变量的类型:\tptype 变量名 观察变量:\twatch 变量名 设置观察点，当这个变量被读出或写入的时候程序暂停 查看观察点的信息:\tinfo watchpoints 显示表达式的值:\tdisplay + 表达式 查看所有要显示的表达式信息： info display 取消显示表达式的值:\tundisplay 编号 改变程序中某个变量的值： set var 变量名=变量值 17、make工程管理工具 make 实际上是一个自动编译管理器，能够根据文件时间戳自动发现更新过的文件从而减少编译的工作量。\n它通过读入makefile文件的内容执行大量的编译工作，提高了项目开放和维护的工作效率。\nmakefile编写规则 1 2  目标体 : 依赖文件 命令    命令前必须带一个Tab\n The simplest example:\n1 2  hello.o : hello.c hello.h gcc hello.c -o hello.o   稍微复杂一点的，存在子规则。有三个c文件,分别为hello.c、sum.c、sub.c\n1 2 3 4 5 6 7 8 9  result : hello.o sum.o sub.o gcc hello.o sum.o sub.o -o result hello.o : hello.c gcc -c hello.c -o hello.o sum.o : sum.c gcc -c sum.c -o sum.o sub.o : sub.c gcc -c sub.c -o sub.o    当某个c文件更新时，只会执行跟这个文件相关的命令\n只有目标文件不存在或者时间戳比依赖文件早，才会重新编译\n 变量 自定义变量  递归展开式的定义格式：var = 值 简单扩展式的定义格式：var := 值  变量使用格式：$(var)  预定义变量 CC : ============\u0026gt; 默认值为cc\nCFLAGS：=========\u0026gt; c编译器的选项\nASFLAGS：========\u0026gt; 汇编程序的选项\nCPPFLAGS：=======\u0026gt; c预编译的选项\n自动变量  $\u0026lt; # 第一个依赖文件 $@ # 目标文件的完整名称 $^ # 所有不重复的依赖文件，以空格分开 $+ # 所有的依赖文件，可能包含重复的，以空格分开 $* # 不包含扩展名的目标文件名称 $? # 所有时间戳比目标文件晚的依赖文件，以空格分开 18、模式规则 %.o : %.c （主要是用来定义相同处理规则的多个文件的）\n将上面的例子可改写为\n1 2 3 4 5 6 7 8 9 10 11  CC=gcc CFLAGS=-Wall -O -g obj=hello.o sum.o sub.o target=result $(target) : $(obj) $(CC) $^ -o $@ %.o : %.c $(CC) $(CFLAGS) -c $\u0026lt; -o $@ clean : rm -r *.o   clean:\nls -l\n加标签 (用于打包，删除，复制等善后工作)\n加- 跳过错误命令继续执行下条命令\n加-g不会比较目标文件与已存在的文件的更新时间\n19、makefile中的相关函数 wildcard 作用：获得指定目录下的文件\n例子：src=$(wildcard ./*.c) : src就等价于当前目录下所有c文件\npatsubst 作用：转换文件后缀\n","description":"初学linux笔记总结","id":17,"section":"posts","tags":["linux"],"title":"linux基础学习","uri":"http://blog.nstop.cn/posts/linux/linux%E5%9F%BA%E7%A1%80/"},{"content":"我，一个想学习又很菜的技术爱好者。永远不想把眼光停滞在事物的表面上，努力去探索世间万物的内涵！ 我唯一拥有的财富是我现在仅存的时光，争取把这种财富100%转化成另外一种或多种财富吧！ 问道有先后，术业有专攻。永远不要拿着自己的长处和别人的短板去比，也不用自惭某些方面不如别人。 ","description":"Hugo, the world’s fastest framework for building websites","id":18,"section":"","tags":null,"title":"About","uri":"http://blog.nstop.cn/about/"}]