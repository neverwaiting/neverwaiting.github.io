<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>设计模式 on WinterSun</title>
    <link>http://blog.zwled.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on WinterSun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>nerverstop@163.com (WinterSun)</managingEditor>
    <webMaster>nerverstop@163.com (WinterSun)</webMaster>
    <copyright>&amp;copy;{year}, All Rights Reserved</copyright>
    <lastBuildDate>Mon, 22 Jun 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://blog.zwled.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    

      
      <item>
        <title>浅谈设计模式</title>
        <link>http://blog.zwled.xyz/posts/cpp/design-pattern/</link>
        <pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate>
        <author>nerverstop@163.com (WinterSun)</author>
        <atom:modified>Mon, 22 Jun 2020 00:00:00 +0000</atom:modified>
        <guid>http://blog.zwled.xyz/posts/cpp/design-pattern/</guid>
        <description>c++设计模式 前言： 我们往往在学习设计模式的时候，总很机械地去想着生搬硬套在某个项目模块中，但这种做法其实违背了设计模式的初衷，设计模式是为了更好地去适应将来的变化，其核心在于隔离稳定和变化的部分，使二者之间的联系不再那么紧密，从而达到我们平常所说的松耦合。而如何能够更好的运用设计模式，并不是你把23种设计模式都记在脑子里，而是在面向对象设计原则的基础上来设计。设计模式的本质是离不开面向对象设计原则的。
面向对象设计原则  依赖倒置原则（DIP）
高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）
抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定） 开放封闭原则（OCP）
对扩展开放，对更改封闭
类模块应该是可扩展的，但是不可修改。 单一职责原则（SRP）
一个类应该仅有一个引起它变化的原因
变化的方向隐含着类的责任 Liskov替换原则（LSP）
子类必须能够替换它们的基类（IS-A）
继承表达类型抽象 接口隔离原则（ISP）
不应该强迫客户程序依赖它们不用的方法
接口应该小而完备 优先使用对象组合，而不是类继承
类继承通常为&amp;quot;白箱复用&amp;quot;，对象组合通常为“黑箱复用”
继承在某种程度上破坏了封装性，子类父类耦合度高
而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。 封装变化点
使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。 针对接口编程，而不是针对实现编程
不将变量类型声明为某个特定的具体类，而是声明为某接口
客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”的类型设计方案。  重构的关键技法   静态 ===&amp;gt; 动态
  早绑定 ===&amp;gt; 晚绑定
  继承 ===&amp;gt; 组合
  编译时依赖 ===&amp;gt; 运行时依赖
  紧耦合 ===&amp;gt; 松耦合
  23种设计模式 Template Method（模板方法） 定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中。Template Method使得子类可以不改变（复用）一个算法的结果即可重定义（override 重写）该算法的某些特定步骤。
Template Method模式是一种非常基础性的设计模式，其根本的机制就是借用虚函数来实现晚绑定，从而为很多应用程序框架提供了灵活多变的扩展点，具有代码复用方面的基本实现结构。
应用场景：
一个功能模块实现的流程已经确定，但其中某些方法现在不能确定其具体实现，因为随着将来的需求会发生各种各样的变化，所以这时候可以考虑设计模式的应用，想想这里的变化部分和稳定部分，稳定部分是一个应用框架流程以及流程中某些确定下来的方法，而变化的部分就是其可扩展的方法实现变化。
c++ example：</description>
        
        <dc:creator>WinterSun</dc:creator>
        
        
        
        
          
            
              <category>设计模式</category>
            
          
        
        
        
      </item>
      

    
  </channel>
</rss>